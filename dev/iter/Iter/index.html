<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Iter (iter.Iter)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">iter</a> &#x00BB; Iter</nav><header class="odoc-preamble"><h1>Module <code><span>Iter</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#simple-and-efficient-iterators">Simple and Efficient Iterators</a></li><li><a href="#creation">Creation</a></li><li><a href="#consumption">Consumption</a></li><li><a href="#transformation">Transformation</a></li><li><a href="#caching">Caching</a></li><li><a href="#misc">Misc</a><ul><li><a href="#set-like">Set-like</a></li><li><a href="#arithmetic">Arithmetic</a></li><li><a href="#list-like">List-like</a></li><li><a href="#pair-iterators">Pair iterators</a></li></ul></li><li><a href="#data-structures-converters">Data structures converters</a><ul><li><a href="#sets">Sets</a></li><li><a href="#maps">Maps</a></li></ul></li><li><a href="#random-iterators">Random iterators</a><ul><li><a href="#sampling">Sampling</a></li></ul></li><li><a href="#infix-functions">Infix functions</a></li><li><a href="#pretty-printing">Pretty printing</a></li><li><a href="#basic-io">Basic IO</a></li></ul></nav><div class="odoc-content"><h2 id="simple-and-efficient-iterators"><a href="#simple-and-efficient-iterators" class="anchor"></a>Simple and Efficient Iterators</h2><p>The iterators are designed to allow easy transfer (mappings) between data structures, without defining <code>n^2</code> conversions between the <code>n</code> types. The implementation relies on the assumption that an iterator can be iterated on as many times as needed; this choice allows for high performance of many combinators. However, for transient iterators, the <a href="#val-persistent"><code>persistent</code></a> function is provided, storing elements of a transient iterator in memory; the iterator can then be used several times (See further).</p><p>Note that some combinators also return iterators (e.g. <code>group</code>). The transformation is computed on the fly every time one iterates over the resulting iterator. If a transformation performs heavy computation, <a href="#val-persistent"><code>persistent</code></a> can also be used as intermediate storage.</p><p>Most functions are <b>lazy</b>, i.e. they do not actually use their arguments until their result is iterated on. For instance, if one calls <a href="#val-map"><code>map</code></a> on an iterator, one gets a new iterator, but nothing else happens until this new iterator is used (by folding or iterating on it).</p><p>If an iterator is built from an iteration function that is <b>repeatable</b> (i.e. calling it several times always iterates on the same set of elements, for instance List.iter or Map.iter), then the resulting <a href="#type-t"><code>t</code></a> object is also repeatable. For <b>one-time iter functions</b> such as iteration on a file descriptor or a <code>Seq</code>, the <a href="#val-persistent"><code>persistent</code></a> function can be used to iterate and store elements in a memory structure; the result is an iterator that iterates on the elements of this memory structure, cheaply and repeatably.</p><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a t</span></span><span> = <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>An iterator of values of type <code>'a</code>. If you give it a function <code>'a -&gt; unit</code> it will be applied to every element of the iterator successively.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-iter" class="anchored"><a href="#type-iter" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a iter</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><p><b>NOTE</b> Type <code>('a, 'b) t2 = ('a -&gt; 'b -&gt; unit) -&gt; unit</code> has been removed and subsumed by <code>('a * 'b) t</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul><div class="odoc-spec"><div class="spec type" id="type-equal" class="anchored"><a href="#type-equal" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a equal</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-hash" class="anchored"><a href="#type-hash" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a hash</span></span><span> = <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><h2 id="creation"><a href="#creation" class="anchor"></a>Creation</h2><div class="odoc-spec"><div class="spec value" id="val-from_iter" class="anchored"><a href="#val-from_iter" class="anchor"></a><code><span><span class="keyword">val</span> from_iter : <span><span>( <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Build an iterator from a iter function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-from_labelled_iter" class="anchored"><a href="#val-from_labelled_iter" class="anchor"></a><code><span><span class="keyword">val</span> from_labelled_iter : <span><span>( <span>f:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Build an iterator from a labelled iter function</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-from_fun" class="anchored"><a href="#val-from_fun" class="anchor"></a><code><span><span class="keyword">val</span> from_fun : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Call the function repeatedly until it returns None. This iterator is transient, use <a href="#val-persistent"><code>persistent</code></a> if needed!</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Empty iterator. It contains no element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-singleton" class="anchored"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Singleton iterator, with exactly one element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-doubleton" class="anchored"><a href="#val-doubleton" class="anchor"></a><code><span><span class="keyword">val</span> doubleton : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator with exactly two elements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-init" class="anchored"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>init f</code> is the infinite iterator <code>f 0; f 1; f 2; …</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-cons" class="anchored"><a href="#val-cons" class="anchor"></a><code><span><span class="keyword">val</span> cons : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cons x l</code> yields <code>x</code>, then yields from <code>l</code>. Same as <code>append (singleton x) l</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-snoc" class="anchored"><a href="#val-snoc" class="anchor"></a><code><span><span class="keyword">val</span> snoc : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-cons"><code>cons</code></a> but yields the element after iterating on <code>l</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-return" class="anchored"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Synonym to <a href="#val-singleton"><code>singleton</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-pure" class="anchored"><a href="#val-pure" class="anchor"></a><code><span><span class="keyword">val</span> pure : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Synonym to <a href="#val-singleton"><code>singleton</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Infinite iterator of the same element. You may want to look at <a href="#val-take"><code>take</code></a> and the likes if you iterate on it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iterate" class="anchored"><a href="#val-iterate" class="anchor"></a><code><span><span class="keyword">val</span> iterate : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>iterate f x</code> is the infinite iterator <code>x, f(x), f(f(x)), ...</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-forever" class="anchored"><a href="#val-forever" class="anchor"></a><code><span><span class="keyword">val</span> forever : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator that calls the given function to produce elements. The iterator may be transient (depending on the function), and definitely is infinite. You may want to use <a href="#val-take"><code>take</code></a> and <a href="#val-persistent"><code>persistent</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cycle" class="anchored"><a href="#val-cycle" class="anchor"></a><code><span><span class="keyword">val</span> cycle : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cycle forever through the given iterator. Assume the given iterator can be traversed any amount of times (not transient). This yields an infinite iterator, you should use something like <a href="#val-take"><code>take</code></a> not to loop forever.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfoldr" class="anchored"><a href="#val-unfoldr" class="anchor"></a><code><span><span class="keyword">val</span> unfoldr : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unfoldr f b</code> will apply <code>f</code> to <code>b</code>. If it yields <code>Some (x,b')</code> then <code>x</code> is returned and unfoldr recurses with <code>b'</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-scan" class="anchored"><a href="#val-scan" class="anchor"></a><code><span><span class="keyword">val</span> scan : <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator of intermediate results</p></div></div><h2 id="consumption"><a href="#consumption" class="anchor"></a>Consumption</h2><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Consume the iterator, passing all its arguments to the function. Basically <code>iter f seq</code> is just <code>seq f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iteri" class="anchored"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on elements and their index in the iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-for_each" class="anchored"><a href="#val-for_each" class="anchor"></a><code><span><span class="keyword">val</span> for_each : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Consume the iterator, passing all its arguments to the function. <code>for_each seq f</code> is the same as <code>iter f seq</code>, i.e., <code>iter</code> with arguments reversed.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-for_eachi" class="anchored"><a href="#val-for_eachi" class="anchor"></a><code><span><span class="keyword">val</span> for_eachi : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on elements and their index in the iterator. <code>for_eachi seq f</code> is the same as <code>iteri f seq</code>, i.e., <code>iteri</code> with arguments reversed.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.4</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold over elements of the iterator, consuming it</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldi" class="anchored"><a href="#val-foldi" class="anchor"></a><code><span><span class="keyword">val</span> foldi : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold over elements of the iterator and their index, consuming it</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_map" class="anchored"><a href="#val-fold_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_map : <span><span>( <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fold_map f acc l</code> is like <a href="#val-map"><code>map</code></a>, but it carries some state as in <a href="#val-fold"><code>fold</code></a>. The state is not returned, it is just used to thread some information to the map function.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_filter_map" class="anchored"><a href="#val-fold_filter_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_filter_map : 
  <span><span>( <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fold_filter_map f acc l</code> is a <a href="#val-fold_map"><code>fold_map</code></a>-like function, but the function can choose to skip an element by retuning <code>None</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map objects of the iterator into other elements, lazily</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapi" class="anchored"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map objects, along with their index in the iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-map_by_2" class="anchored"><a href="#val-map_by_2" class="anchor"></a><code><span><span class="keyword">val</span> map_by_2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map objects two by two. lazily. The last element is kept in the iterator if the count is odd.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.7</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-for_all" class="anchored"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Do all elements satisfy the predicate?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-exists" class="anchored"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Exists there some element satisfying the predicate?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the value a member of the iterator?</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">eq</span> <p>the equality predicate to use (default <code>(=)</code>)</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p>Find the first element on which the function doesn't return <code>None</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_map" class="anchored"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p>Alias to <a href="#val-find"><code>find</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-findi" class="anchored"><a href="#val-findi" class="anchor"></a><code><span><span class="keyword">val</span> findi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p>Indexed version of <a href="#val-find"><code>find</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_mapi" class="anchored"><a href="#val-find_mapi" class="anchor"></a><code><span><span class="keyword">val</span> find_mapi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p>Alias to <a href="#val-findi"><code>findi</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_pred" class="anchored"><a href="#val-find_pred" class="anchor"></a><code><span><span class="keyword">val</span> find_pred : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_pred p l</code> finds the first element of <code>l</code> that satisfies <code>p</code>, or returns <code>None</code> if no element satisfies <code>p</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-find_pred_exn" class="anchored"><a href="#val-find_pred_exn" class="anchor"></a><code><span><span class="keyword">val</span> find_pred_exn : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Unsafe version of <a href="#val-find_pred"><code>find_pred</code></a></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if no such element is found</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>How long is the iterator? Forces the iterator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Is the iterator empty? Forces the iterator.</p></div></div><h2 id="transformation"><a href="#transformation" class="anchor"></a>Transformation</h2><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Filter on elements of the iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Append two iterators. Iterating on the result is like iterating on the first, then on the second.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append_l" class="anchored"><a href="#val-append_l" class="anchor"></a><code><span><span class="keyword">val</span> append_l : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Append iterators. Iterating on the result is like iterating on the each iterator of the list in order.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Concatenate an iterator of iterators into one iterator.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Alias for <a href="#val-concat"><code>concat</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map" class="anchored"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Monadic bind. Intuitively, it applies the function to every element of the initial iterator, and calls <a href="#val-concat"><code>concat</code></a>. Formerly <code>flatMap</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map_l" class="anchored"><a href="#val-flat_map_l" class="anchor"></a><code><span><span class="keyword">val</span> flat_map_l : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Convenience function combining <a href="#val-flat_map"><code>flat_map</code></a> and <a href="#val-of_list"><code>of_list</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-seq_list" class="anchored"><a href="#val-seq_list" class="anchor"></a><code><span><span class="keyword">val</span> seq_list : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq_list l</code> returns all the ways to pick one element in each sub-iterator in <code>l</code>. Assumes the sub-iterators can be iterated on several times.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-seq_list_map" class="anchored"><a href="#val-seq_list_map" class="anchor"></a><code><span><span class="keyword">val</span> seq_list_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq_list_map f l</code> maps <code>f</code> over every element of <code>l</code>, then calls <a href="#val-seq_list"><code>seq_list</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map and only keep non-<code>None</code> elements Formerly <code>fmap</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_mapi" class="anchored"><a href="#val-filter_mapi" class="anchor"></a><code><span><span class="keyword">val</span> filter_mapi : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map with indices, and only keep non-<code>None</code> elements</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_count" class="anchored"><a href="#val-filter_count" class="anchor"></a><code><span><span class="keyword">val</span> filter_count : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Count how many elements satisfy the given predicate</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-intersperse" class="anchored"><a href="#val-intersperse" class="anchor"></a><code><span><span class="keyword">val</span> intersperse : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Insert the single element between every element of the iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-keep_some" class="anchored"><a href="#val-keep_some" class="anchor"></a><code><span><span class="keyword">val</span> keep_some : <span><span><span><span class="type-var">'a</span> option</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_some l</code> retains only elements of the form <code>Some x</code>. Same as <code>filter_map (fun x-&gt;x)</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-keep_ok" class="anchored"><a href="#val-keep_ok" class="anchor"></a><code><span><span class="keyword">val</span> keep_ok : <span><span><span><span>( <span class="type-var">'a</span>, <span class="type-var">_</span> )</span> <span class="xref-unresolved">Result</span>.result</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>keep_ok l</code> retains only elements of the form <code>Ok x</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-keep_error" class="anchored"><a href="#val-keep_error" class="anchor"></a><code><span><span class="keyword">val</span> keep_error : <span><span><span><span>( <span class="type-var">_</span>, <span class="type-var">'e</span> )</span> <span class="xref-unresolved">Result</span>.result</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'e</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>keep_error l</code> retains only elements of the form <code>Error x</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0</li></ul></div></div><h2 id="caching"><a href="#caching" class="anchor"></a>Caching</h2><div class="odoc-spec"><div class="spec value" id="val-persistent" class="anchored"><a href="#val-persistent" class="anchor"></a><code><span><span class="keyword">val</span> persistent : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the iterator, storing elements in an efficient internal structure.. The resulting iterator can be iterated on as many times as needed. <b>Note</b>: calling persistent on an already persistent iterator will still make a new copy of the iterator!</p></div></div><div class="odoc-spec"><div class="spec value" id="val-persistent_lazy" class="anchored"><a href="#val-persistent_lazy" class="anchor"></a><code><span><span class="keyword">val</span> persistent_lazy : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Lazy version of <a href="#val-persistent"><code>persistent</code></a>. When calling <code>persistent_lazy s</code>, a new iterator <code>s'</code> is immediately returned (without actually consuming <code>s</code>) in constant time; the first time <code>s'</code> is iterated on, it also consumes <code>s</code> and caches its content into a inner data structure that will back <code>s'</code> for future iterations.</p><p><b>warning</b>: on the first traversal of <code>s'</code>, if the traversal is interrupted prematurely (<a href="#val-take"><code>take</code></a>, etc.) then <code>s'</code> will not be memorized, and the next call to <code>s'</code> will traverse <code>s</code> again.</p></div></div><h2 id="misc"><a href="#misc" class="anchor"></a>Misc</h2><div class="odoc-spec"><div class="spec value" id="val-sort" class="anchored"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Sort the iterator. Eager, O(n) ram and O(n ln(n)) time. It iterates on elements of the argument iterator immediately, before it sorts them.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sort_uniq" class="anchored"><a href="#val-sort_uniq" class="anchor"></a><code><span><span class="keyword">val</span> sort_uniq : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Sort the iterator and remove duplicates. Eager, same as <code>sort</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-sorted" class="anchored"><a href="#val-sorted" class="anchor"></a><code><span><span class="keyword">val</span> sorted : <span>?cmp:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Checks whether the iterator is sorted. Eager, same as <a href="#val-sort"><code>sort</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_succ_by" class="anchored"><a href="#val-group_succ_by" class="anchor"></a><code><span><span class="keyword">val</span> group_succ_by : <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Group equal consecutive elements. Linear time. Formerly synonym to <code>group</code>. <b>note</b>: Order of items in each list is unspecified.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.6</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_by" class="anchored"><a href="#val-group_by" class="anchor"></a><code><span><span class="keyword">val</span> group_by : 
  <span>?hash:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Group equal elements, disregarding their order of appearance. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold. <b>note</b>: Order of items in each list is unspecified.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.6</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : 
  <span>?hash:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * int)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Map each distinct element to its number of occurrences in the whole seq. Similar to <code>group_by seq |&gt; map (fun l-&gt;List.hd l, List.length l)</code> precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-uniq" class="anchored"><a href="#val-uniq" class="anchor"></a><code><span><span class="keyword">val</span> uniq : <span>?eq:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Remove consecutive duplicate elements. Basically this is like <code>fun seq -&gt; map List.hd (group seq)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product" class="anchored"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Cartesian product of iterators. When calling <code>product a b</code>, the caller <b>MUST</b> ensure that <code>b</code> can be traversed as many times as required (several times), possibly by calling <a href="#val-persistent"><code>persistent</code></a> on it beforehand.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-diagonal_l" class="anchored"><a href="#val-diagonal_l" class="anchor"></a><code><span><span class="keyword">val</span> diagonal_l : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>All pairs of distinct positions of the list. <code>diagonal l</code> will return the iterator of all <code>List.nth i l, List.nth j l</code> if <code>i &lt; j</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-diagonal" class="anchored"><a href="#val-diagonal" class="anchor"></a><code><span><span class="keyword">val</span> diagonal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>All pairs of distinct positions of the iterator. Iterates only once on the iterator, which must be finite.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.9</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span>join_row:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join ~join_row a b</code> combines every element of <code>a</code> with every element of <code>b</code> using <code>join_row</code>. If <code>join_row</code> returns None, then the two elements do not combine. Assume that <code>b</code> allows for multiple iterations.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-join_by" class="anchored"><a href="#val-join_by" class="anchor"></a><code><span><span class="keyword">val</span> join_by : 
  <span>?eq:<span><span class="type-var">'key</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?hash:<span><span class="type-var">'key</span> <a href="#type-hash">hash</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>merge:<span>( <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join key1 key2 ~merge</code> is a binary operation that takes two iterators <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and combine values <code>(x,y)</code> from <code>(a,b)</code> with the same <code>key</code> using <code>merge</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-join_all_by" class="anchored"><a href="#val-join_all_by" class="anchor"></a><code><span><span class="keyword">val</span> join_all_by : 
  <span>?eq:<span><span class="type-var">'key</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?hash:<span><span class="type-var">'key</span> <a href="#type-hash">hash</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'key</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>merge:<span>( <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>join_all_by key1 key2 ~merge</code> is a binary operation that takes two iterators <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and, for each key <code>k</code> occurring in at least one of them:</p><ul><li>compute the list <code>l1</code> of elements of <code>a</code> that map to <code>k</code></li><li>compute the list <code>l2</code> of elements of <code>b</code> that map to <code>k</code></li><li>call <code>merge k l1 l2</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded, otherwise it returns <code>Some c</code> and <code>c</code> is inserted in the result.</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-group_join_by" class="anchored"><a href="#val-group_join_by" class="anchor"></a><code><span><span class="keyword">val</span> group_join_by : 
  <span>?eq:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>?hash:<span><span class="type-var">'a</span> <a href="#type-hash">hash</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'b</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>group_join_by key2</code> associates to every element <code>x</code> of the first iterator, all the elements <code>y</code> of the second iterator such that <code>eq x (key y)</code>. Elements of the first iterators without corresponding values in the second one are mapped to <code>[]</code> precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><h3 id="set-like"><a href="#set-like" class="anchor"></a>Set-like</h3><div class="odoc-spec"><div class="spec value" id="val-inter" class="anchored"><a href="#val-inter" class="anchor"></a><code><span><span class="keyword">val</span> inter : <span>?eq:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?hash:<span><span class="type-var">'a</span> <a href="#type-hash">hash</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Intersection of two collections. Each element will occur at most once in the result. Eager. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-union" class="anchored"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span>?eq:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?hash:<span><span class="type-var">'a</span> <a href="#type-hash">hash</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Union of two collections. Each element will occur at most once in the result. Eager. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-diff" class="anchored"><a href="#val-diff" class="anchor"></a><code><span><span class="keyword">val</span> diff : <span>?eq:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?hash:<span><span class="type-var">'a</span> <a href="#type-hash">hash</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Set difference. Eager.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-subset" class="anchored"><a href="#val-subset" class="anchor"></a><code><span><span class="keyword">val</span> subset : <span>?eq:<span><span class="type-var">'a</span> <a href="#type-equal">equal</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?hash:<span><span class="type-var">'a</span> <a href="#type-hash">hash</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>subset a b</code> returns <code>true</code> if all elements of <code>a</code> belong to <code>b</code>. Eager. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><h3 id="arithmetic"><a href="#arithmetic" class="anchor"></a>Arithmetic</h3><div class="odoc-spec"><div class="spec value" id="val-max" class="anchored"><a href="#val-max" class="anchor"></a><code><span><span class="keyword">val</span> max : <span>?lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Max element of the iterator, using the given comparison function.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>None if the iterator is empty, Some <code>m</code> where <code>m</code> is the maximal element otherwise</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-max_exn" class="anchored"><a href="#val-max_exn" class="anchor"></a><code><span><span class="keyword">val</span> max_exn : <span>?lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Unsafe version of <a href="#val-max"><code>max</code></a></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the iterator is empty</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-min" class="anchored"><a href="#val-min" class="anchor"></a><code><span><span class="keyword">val</span> min : <span>?lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Min element of the iterator, using the given comparison function. see <a href="#val-max"><code>max</code></a> for more details.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-min_exn" class="anchored"><a href="#val-min_exn" class="anchor"></a><code><span><span class="keyword">val</span> min_exn : <span>?lt:<span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Unsafe version of <a href="#val-min"><code>min</code></a></p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Not_found</span> <p>if the iterator is empty</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sum" class="anchored"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span>int <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Sum of elements</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-sumf" class="anchored"><a href="#val-sumf" class="anchor"></a><code><span><span class="keyword">val</span> sumf : <span><span>float <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Sum of elements, using Kahan summation</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><h3 id="list-like"><a href="#list-like" class="anchor"></a>List-like</h3><div class="odoc-spec"><div class="spec value" id="val-head" class="anchored"><a href="#val-head" class="anchor"></a><code><span><span class="keyword">val</span> head : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>First element, if any, otherwise <code>None</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-head_exn" class="anchored"><a href="#val-head_exn" class="anchor"></a><code><span><span class="keyword">val</span> head_exn : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>First element, if any, fails</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the iterator is empty</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Take at most <code>n</code> elements from the iterator. Works on infinite iterators.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Take elements while they satisfy the predicate, then stops iterating. Will work on an infinite iterator <code>s</code> if the predicate is false for at least one element of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_while" class="anchored"><a href="#val-fold_while" class="anchor"></a><code><span><span class="keyword">val</span> fold_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span>[ `Stop <span>| `Continue</span> ]</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Folds over elements of the iterator, stopping early if the accumulator returns <code>('a, `Stop)</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Drop the <code>n</code> first elements of the iterator. Lazy.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Predicate version of <a href="#val-drop"><code>drop</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev" class="anchored"><a href="#val-rev" class="anchor"></a><code><span><span class="keyword">val</span> rev : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Reverse the iterator. O(n) memory and time, needs the iterator to be finite. The result is persistent and does not depend on the input being repeatable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_i" class="anchored"><a href="#val-zip_i" class="anchor"></a><code><span><span class="keyword">val</span> zip_i : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Zip elements of the iterator with their index in the iterator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.0 Changed type to just give an iterator of pairs</li></ul></div></div><h3 id="pair-iterators"><a href="#pair-iterators" class="anchor"></a>Pair iterators</h3><div class="odoc-spec"><div class="spec value" id="val-fold2" class="anchored"><a href="#val-fold2" class="anchor"></a><code><span><span class="keyword">val</span> fold2 : <span><span>( <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-iter2" class="anchored"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-map2" class="anchored"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-map2_2" class="anchored"><a href="#val-map2_2" class="anchor"></a><code><span><span class="keyword">val</span> map2_2 : 
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'c</span> * <span class="type-var">'d</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map2_2 f g seq2</code> maps each <code>x, y</code> of seq2 into <code>f x y, g x y</code></p></div></div><h2 id="data-structures-converters"><a href="#data-structures-converters" class="anchor"></a>Data structures converters</h2><div class="odoc-spec"><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Convert the iterator into a list. Preserves order of elements. This function is tail-recursive, but consumes 2*n memory. If order doesn't matter to you, consider <a href="#val-to_rev_list"><code>to_rev_list</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_rev_list" class="anchored"><a href="#val-to_rev_list" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Get the list of the reversed iterator (more efficient than <a href="#val-to_list"><code>to_list</code></a>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-on_list" class="anchored"><a href="#val-on_list" class="anchor"></a><code><span><span class="keyword">val</span> on_list : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>on_list f l</code> is equivalent to <code>to_list @@ f @@ of_list l</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5.2</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-pair_with_idx" class="anchored"><a href="#val-pair_with_idx" class="anchor"></a><code><span><span class="keyword">val</span> pair_with_idx : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-zip_i"><code>zip_i</code></a> but returns a normal iterator of tuples</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.11</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_opt" class="anchored"><a href="#val-to_opt" class="anchor"></a><code><span><span class="keyword">val</span> to_opt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Alias to <a href="#val-head"><code>head</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_array" class="anchored"><a href="#val-to_array" class="anchor"></a><code><span><span class="keyword">val</span> to_array : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>Convert to an array. Currently not very efficient because an intermediate list is used.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_array" class="anchored"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_array_i" class="anchored"><a href="#val-of_array_i" class="anchor"></a><code><span><span class="keyword">val</span> of_array_i : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Elements of the array, with their index</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array_slice" class="anchored"><a href="#val-array_slice" class="anchor"></a><code><span><span class="keyword">val</span> array_slice : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>array_slice a i j</code> Iterator of elements whose indexes range from <code>i</code> to <code>j</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_opt" class="anchored"><a href="#val-of_opt" class="anchor"></a><code><span><span class="keyword">val</span> of_opt : <span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterate on 0 or 1 values.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5.1</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_seq" class="anchored"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator of elements of a <code>Seq</code>.t.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_seq_persistent" class="anchored"><a href="#val-to_seq_persistent" class="anchor"></a><code><span><span class="keyword">val</span> to_seq_persistent : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Convert to a <code>Seq</code>. Linear in memory and time (a copy is made in memory). This does not work on infinite iterators.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_stack" class="anchored"><a href="#val-to_stack" class="anchor"></a><code><span><span class="keyword">val</span> to_stack : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Stack.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Push elements of the iterator on the stack</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_stack" class="anchored"><a href="#val-of_stack" class="anchor"></a><code><span><span class="keyword">val</span> of_stack : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Stack.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator of elements of the stack (same order as <code>Stack.iter</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_queue" class="anchored"><a href="#val-to_queue" class="anchor"></a><code><span><span class="keyword">val</span> to_queue : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Queue.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Push elements of the iterator into the queue</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_queue" class="anchored"><a href="#val-of_queue" class="anchor"></a><code><span><span class="keyword">val</span> of_queue : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Queue.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator of elements contained in the queue, FIFO order</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hashtbl_add" class="anchored"><a href="#val-hashtbl_add" class="anchor"></a><code><span><span class="keyword">val</span> hashtbl_add : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add elements of the iterator to the hashtable, with Hashtbl.add</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hashtbl_replace" class="anchored"><a href="#val-hashtbl_replace" class="anchor"></a><code><span><span class="keyword">val</span> hashtbl_replace : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Add elements of the iterator to the hashtable, with Hashtbl.replace (erases conflicting bindings)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_hashtbl" class="anchored"><a href="#val-to_hashtbl" class="anchor"></a><code><span><span class="keyword">val</span> to_hashtbl : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span></span></code></div><div class="spec-doc"><p>Build a hashtable from an iterator of key/value pairs</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_hashtbl" class="anchored"><a href="#val-of_hashtbl" class="anchor"></a><code><span><span class="keyword">val</span> of_hashtbl : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator of key/value pairs from the hashtable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hashtbl_keys" class="anchored"><a href="#val-hashtbl_keys" class="anchor"></a><code><span><span class="keyword">val</span> hashtbl_keys : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-hashtbl_values" class="anchored"><a href="#val-hashtbl_values" class="anchor"></a><code><span><span class="keyword">val</span> hashtbl_values : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_str" class="anchored"><a href="#val-of_str" class="anchor"></a><code><span><span class="keyword">val</span> of_str : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-to_str" class="anchored"><a href="#val-to_str" class="anchor"></a><code><span><span class="keyword">val</span> to_str : <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-concat_str" class="anchored"><a href="#val-concat_str" class="anchor"></a><code><span><span class="keyword">val</span> concat_str : <span><span>string <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Concatenate strings together, eagerly. Also see <a href="#val-intersperse"><code>intersperse</code></a> to add a separator.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec exception" id="exception-OneShotSequence" class="anchored"><a href="#exception-OneShotSequence" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">OneShotSequence</span></span></code></div><div class="spec-doc"><p>Raised when the user tries to iterate several times on a transient iterator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_in_channel" class="anchored"><a href="#val-of_in_channel" class="anchor"></a><code><span><span class="keyword">val</span> of_in_channel : <span><span class="xref-unresolved">Stdlib</span>.in_channel <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterates on characters of the input (can block when one iterates over the iterator). If you need to iterate several times on this iterator, use <a href="#val-persistent"><code>persistent</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">OneShotIterator</span> <p>when used more than once.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_buffer" class="anchored"><a href="#val-to_buffer" class="anchor"></a><code><span><span class="keyword">val</span> to_buffer : <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Copy content of the iterator into the buffer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_range" class="anchored"><a href="#val-int_range" class="anchor"></a><code><span><span class="keyword">val</span> int_range : <span>start:int <span class="arrow">&#45;&gt;</span></span> <span>stop:int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator on integers in <code>start...stop</code> by steps 1. Also see <a href="#val-(--)"><code>(--)</code></a> for an infix version.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_range_dec" class="anchored"><a href="#val-int_range_dec" class="anchor"></a><code><span><span class="keyword">val</span> int_range_dec : <span>start:int <span class="arrow">&#45;&gt;</span></span> <span>stop:int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator on decreasing integers in <code>stop...start</code> by steps -1. See <a href="#val-(--^)"><code>(--^)</code></a> for an infix version</p></div></div><div class="odoc-spec"><div class="spec value" id="val-int_range_by" class="anchored"><a href="#val-int_range_by" class="anchor"></a><code><span><span class="keyword">val</span> int_range_by : <span>step:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>int_range_by ~step i j</code> is the range starting at <code>i</code>, including <code>j</code>, where the difference between successive elements is <code>step</code>. use a negative <code>step</code> for a decreasing iterator.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>step=0</code></p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-bools" class="anchored"><a href="#val-bools" class="anchor"></a><code><span><span class="keyword">val</span> bools : <span>bool <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterates on <code>true</code> and <code>false</code></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.7</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_set" class="anchored"><a href="#val-of_set" class="anchor"></a><code><span><span class="keyword">val</span> of_set : 
  <span><span>(<span class="keyword">module</span> <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="type-var">'a</span> <span class="keyword">and</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Convert the given set to an iterator. The set module must be provided.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_set" class="anchored"><a href="#val-to_set" class="anchor"></a><code><span><span class="keyword">val</span> to_set : 
  <span><span>(<span class="keyword">module</span> <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="type-var">'a</span> <span class="keyword">and</span> <span class="keyword">type</span> <span class="xref-unresolved">t</span> = <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Convert the iterator to a set, given the proper set module</p></div></div><div class="odoc-spec"><div class="spec type" id="type-gen" class="anchored"><a href="#type-gen" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a gen</span></span><span> = <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-of_gen" class="anchored"><a href="#val-of_gen" class="anchor"></a><code><span><span class="keyword">val</span> of_gen : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Traverse eagerly the generator and build an iterator from it</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_gen_once" class="anchored"><a href="#val-of_gen_once" class="anchor"></a><code><span><span class="keyword">val</span> of_gen_once : <span><span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>One shot iterator using this generator. It must not be traversed twice.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 1.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_gen" class="anchored"><a href="#val-to_gen" class="anchor"></a><code><span><span class="keyword">val</span> to_gen : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-gen">gen</a></span></span></code></div><div class="spec-doc"><p>Make the iterator persistent (O(n)) and then iterate on it. Eager.</p></div></div><h3 id="sets"><a href="#sets" class="anchor"></a>Sets</h3><div class="odoc-spec"><div class="spec module" id="module-Set" class="anchored"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Set/index.html">Set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="maps"><a href="#maps" class="anchor"></a>Maps</h3><div class="odoc-spec"><div class="spec module" id="module-Map" class="anchored"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="random-iterators"><a href="#random-iterators" class="anchor"></a>Random iterators</h2><div class="odoc-spec"><div class="spec value" id="val-random_int" class="anchored"><a href="#val-random_int" class="anchor"></a><code><span><span class="keyword">val</span> random_int : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Infinite iterator of random integers between 0 and the given higher bound (see Random.int)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-random_bool" class="anchored"><a href="#val-random_bool" class="anchor"></a><code><span><span class="keyword">val</span> random_bool : <span>bool <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Infinite iterator of random bool values</p></div></div><div class="odoc-spec"><div class="spec value" id="val-random_float" class="anchored"><a href="#val-random_float" class="anchor"></a><code><span><span class="keyword">val</span> random_float : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-random_array" class="anchored"><a href="#val-random_array" class="anchor"></a><code><span><span class="keyword">val</span> random_array : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Iterator of choices of an element in the array</p></div></div><div class="odoc-spec"><div class="spec value" id="val-random_list" class="anchored"><a href="#val-random_list" class="anchor"></a><code><span><span class="keyword">val</span> random_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Infinite iterator of random elements of the list. Basically the same as <a href="#val-random_array"><code>random_array</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shuffle" class="anchored"><a href="#val-shuffle" class="anchor"></a><code><span><span class="keyword">val</span> shuffle : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>shuffle seq</code> returns a perfect shuffle of <code>seq</code>. Uses O(length seq) memory and time. Eager.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.7</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-shuffle_buffer" class="anchored"><a href="#val-shuffle_buffer" class="anchor"></a><code><span><span class="keyword">val</span> shuffle_buffer : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>shuffle_buffer n seq</code> returns an iterator of element of <code>seq</code> in random order. The shuffling is *not* uniform. Uses O(n) memory.</p><p>The first <code>n</code> elements of the iterator are consumed immediately. The rest is consumed lazily.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.7</li></ul></div></div><h3 id="sampling"><a href="#sampling" class="anchor"></a>Sampling</h3><div class="odoc-spec"><div class="spec value" id="val-sample" class="anchored"><a href="#val-sample" class="anchor"></a><code><span><span class="keyword">val</span> sample : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>sample n seq</code> returns k samples of <code>seq</code>, with uniform probability. It will consume the iterator and use O(n) memory.</p><p>It returns an array of size <code>min (length seq) n</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.7</li></ul></div></div><h2 id="infix-functions"><a href="#infix-functions" class="anchor"></a>Infix functions</h2><div class="odoc-spec"><div class="spec module" id="module-Infix" class="anchored"><a href="#module-Infix" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Infix/index.html">Infix</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="Infix/index.html">Infix</a></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>a -- b</code> is the range of integers from <code>a</code> to <code>b</code>, both included, in increasing order. It will therefore be empty if <code>a &gt; b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--^)" class="anchored"><a href="#val-(--^)" class="anchor"></a><code><span><span class="keyword">val</span> (--^) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>a --^ b</code> is the range of integers from <code>b</code> to <code>a</code>, both included, in decreasing order (starts from <code>a</code>). It will therefore be empty if <code>a &lt; b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Monadic bind (infix version of <a href="#val-flat_map"><code>flat_map</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;|=)" class="anchored"><a href="#val-(&gt;|=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;|=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Infix version of <a href="#val-map"><code>map</code></a></p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*&gt;) : <span><span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Applicative operator (product+application)</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;+&gt;)" class="anchored"><a href="#val-(&lt;+&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;+&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Concatenation of iterators</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5</li></ul></div></div></details></div><h2 id="pretty-printing"><a href="#pretty-printing" class="anchor"></a>Pretty printing</h2><div class="odoc-spec"><div class="spec value" id="val-pp_seq" class="anchored"><a href="#val-pp_seq" class="anchor"></a><code><span><span class="keyword">val</span> pp_seq : 
  <span>?sep:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Pretty print an iterator of <code>'a</code>, using the given pretty printer to print each elements. An optional separator string can be provided.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_buf" class="anchored"><a href="#val-pp_buf" class="anchor"></a><code><span><span class="keyword">val</span> pp_buf : 
  <span>?sep:string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Buffer.t <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Print into a buffer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span>?sep:string <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Print into a string</p></div></div><h2 id="basic-io"><a href="#basic-io" class="anchor"></a>Basic IO</h2><p>Very basic interface to manipulate files as iterator of chunks/lines. The iterators take care of opening and closing files properly; every time one iterates over an iterator, the file is opened/closed again.</p><p>Example: copy a file <code>&quot;a&quot;</code> into file <code>&quot;b&quot;</code>, removing blank lines:</p><pre><code>Iterator.(IO.lines_of &quot;a&quot; |&gt; filter (fun l-&gt; l&lt;&gt; &quot;&quot;) |&gt; IO.write_lines &quot;b&quot;);;</code></pre><p>By chunks of <code>4096</code> bytes:</p><pre><code>Iterator.IO.(chunks_of ~size:4096 &quot;a&quot; |&gt; write_to &quot;b&quot;);;</code></pre><p>Read the lines of a file into a list:</p><pre><code>Iterator.IO.lines &quot;a&quot; |&gt; Iterator.to_list</code></pre><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.5.1</li></ul><div class="odoc-spec"><div class="spec module" id="module-IO" class="anchored"><a href="#module-IO" class="anchor"></a><code><span><span class="keyword">module</span> <a href="IO/index.html">IO</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>