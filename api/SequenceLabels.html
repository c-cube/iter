<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Sequence.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Sequence" rel="Chapter" href="Sequence.html">
<link title="SequenceLabels" rel="Chapter" href="SequenceLabels.html"><link title="Build a sequence" rel="Section" href="#2_Buildasequence">
<link title="Consume a sequence" rel="Section" href="#2_Consumeasequence">
<link title="Transform a sequence" rel="Section" href="#2_Transformasequence">
<link title="Caching" rel="Section" href="#2_Caching">
<link title="Misc" rel="Section" href="#2_Misc">
<link title="Binary sequences" rel="Section" href="#2_Binarysequences">
<link title="Basic data structures converters" rel="Section" href="#2_Basicdatastructuresconverters">
<link title="Functorial conversions between sets and sequences" rel="Section" href="#2_Functorialconversionsbetweensetsandsequences">
<link title="Conversion between maps and sequences." rel="Section" href="#2_Conversionbetweenmapsandsequences">
<link title="Infinite sequences of random values" rel="Section" href="#2_Infinitesequencesofrandomvalues">
<link title="Sampling" rel="Section" href="#2_Sampling">
<link title="Infix functions" rel="Section" href="#2_Infixfunctions">
<link title="Pretty printing of sequences" rel="Section" href="#2_Prettyprintingofsequences">
<link title="Basic IO" rel="Section" href="#2_BasicIO">
<title>SequenceLabels</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Sequence.html" title="Sequence">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_SequenceLabels.html">SequenceLabels</a></h1>

<pre><span class="keyword">module</span> SequenceLabels: <code class="code">sig</code> <a href="SequenceLabels.html">..</a> <code class="code">end</code></pre><div class="info module top">
<h1 id="1_SimpleandEfficientIterators">Simple and Efficient Iterators</h1>
<p>

    Version of <a href="Sequence.html"><code class="code">Sequence</code></a> with labels<br>
<b>Since</b> 0.5.5<br>
</div>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> = <code class="type">('a -> unit) -> unit</code> </pre>
<div class="info ">
A sequence of values of type <code class="code">'a</code>. If you give it a function <code class="code">'a -&gt; unit</code>
    it will be applied to every element of the sequence successively.<br>
</div>


<pre><span id="TYPEsequence"><span class="keyword">type</span> <code class="type">'a</code> sequence</span> = <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a></code> </pre>


<pre><span id="TYPEt2"><span class="keyword">type</span> <code class="type">('a, 'b)</code> t2</span> = <code class="type">('a -> 'b -> unit) -> unit</code> </pre>
<div class="info ">
Sequence of pairs of values of type <code class="code">'a</code> and <code class="code">'b</code>.<br>
</div>


<pre><span id="TYPEequal"><span class="keyword">type</span> <code class="type">'a</code> equal</span> = <code class="type">'a -> 'a -> bool</code> </pre>


<pre><span id="TYPEhash"><span class="keyword">type</span> <code class="type">'a</code> hash</span> = <code class="type">'a -> int</code> </pre>

<br>
<h2 id="2_Buildasequence">Build a sequence</h2><br>

<pre><span id="VALfrom_iter"><span class="keyword">val</span> from_iter</span> : <code class="type">(('a -> unit) -> unit) -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Build a sequence from a iter function<br>
</div>

<pre><span id="VALfrom_fun"><span class="keyword">val</span> from_fun</span> : <code class="type">(unit -> 'a option) -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Call the function repeatedly until it returns None. This
    sequence is transient, use <a href="SequenceLabels.html#VALpersistent"><code class="code">SequenceLabels.persistent</code></a> if needed!<br>
</div>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Empty sequence. It contains no element.<br>
</div>

<pre><span id="VALsingleton"><span class="keyword">val</span> singleton</span> : <code class="type">'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Singleton sequence, with exactly one element.<br>
</div>

<pre><span id="VALdoubleton"><span class="keyword">val</span> doubleton</span> : <code class="type">'a -> 'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence with exactly two elements<br>
</div>

<pre><span id="VALinit"><span class="keyword">val</span> init</span> : <code class="type">f:(int -> 'a) -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">init f</code> is the infinite sequence <code class="code">f 0; f 1; f 2; â€¦</code>.<br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALcons"><span class="keyword">val</span> cons</span> : <code class="type">'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">cons x l</code> yields <code class="code">x</code>, then yields from <code class="code">l</code>.
    Same as <code class="code">append (singleton x) l</code><br>
</div>

<pre><span id="VALsnoc"><span class="keyword">val</span> snoc</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Same as <a href="SequenceLabels.html#VALcons"><code class="code">SequenceLabels.cons</code></a> but yields the element after iterating on <code class="code">l</code><br>
</div>

<pre><span id="VALreturn"><span class="keyword">val</span> return</span> : <code class="type">'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Synonym to <a href="SequenceLabels.html#VALsingleton"><code class="code">SequenceLabels.singleton</code></a><br>
</div>

<pre><span id="VALpure"><span class="keyword">val</span> pure</span> : <code class="type">'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Synonym to <a href="SequenceLabels.html#VALsingleton"><code class="code">SequenceLabels.singleton</code></a><br>
</div>

<pre><span id="VALrepeat"><span class="keyword">val</span> repeat</span> : <code class="type">'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Infinite sequence of the same element. You may want to look
    at <a href="SequenceLabels.html#VALtake"><code class="code">SequenceLabels.take</code></a> and the likes if you iterate on it.<br>
</div>

<pre><span id="VALiterate"><span class="keyword">val</span> iterate</span> : <code class="type">('a -> 'a) -> 'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">iterate f x</code> is the infinite sequence <code class="code">x, f(x), f(f(x)), ...</code><br>
</div>

<pre><span id="VALforever"><span class="keyword">val</span> forever</span> : <code class="type">(unit -> 'b) -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence that calls the given function to produce elements.
    The sequence may be transient (depending on the function), and definitely
    is infinite. You may want to use <a href="SequenceLabels.html#VALtake"><code class="code">SequenceLabels.take</code></a> and <a href="SequenceLabels.html#VALpersistent"><code class="code">SequenceLabels.persistent</code></a>.<br>
</div>

<pre><span id="VALcycle"><span class="keyword">val</span> cycle</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Cycle forever through the given sequence. Assume the given sequence can
    be traversed any amount of times (not transient).  This yields an
    infinite sequence, you should use something like <a href="SequenceLabels.html#VALtake"><code class="code">SequenceLabels.take</code></a> not to loop
    forever.<br>
</div>
<br>
<h2 id="2_Consumeasequence">Consume a sequence</h2><br>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">f:('a -> unit) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Consume the sequence, passing all its arguments to the function.
    Basically <code class="code">iter f seq</code> is just <code class="code">seq f</code>.<br>
</div>

<pre><span id="VALiteri"><span class="keyword">val</span> iteri</span> : <code class="type">f:(int -> 'a -> unit) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Iterate on elements and their index in the sequence<br>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">f:('a -> 'b -> 'a) -> init:'a -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Fold over elements of the sequence, consuming it<br>
</div>

<pre><span id="VALfoldi"><span class="keyword">val</span> foldi</span> : <code class="type">f:('a -> int -> 'b -> 'a) -> init:'a -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Fold over elements of the sequence and their index, consuming it<br>
</div>

<pre><span id="VALfold_map"><span class="keyword">val</span> fold_map</span> : <code class="type">f:('acc -> 'a -> 'acc * 'b) -><br>       init:'acc -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">fold_map f acc l</code> is like <a href="SequenceLabels.html#VALmap"><code class="code">SequenceLabels.map</code></a>, but it carries some state as in
    <a href="SequenceLabels.html#VALfold"><code class="code">SequenceLabels.fold</code></a>. The state is not returned, it is just used to thread some
    information to the map function.<br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALfold_filter_map"><span class="keyword">val</span> fold_filter_map</span> : <code class="type">f:('acc -> 'a -> 'acc * 'b option) -><br>       init:'acc -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">fold_filter_map f acc l</code> is a <a href="SequenceLabels.html#VALfold_map"><code class="code">SequenceLabels.fold_map</code></a>-like function, but the
    function can choose to skip an element by retuning <code class="code">None</code>.<br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">f:('a -> 'b) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Map objects of the sequence into other elements, lazily<br>
</div>

<pre><span id="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">f:(int -> 'a -> 'b) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Map objects, along with their index in the sequence<br>
</div>

<pre><span id="VALmap_by_2"><span class="keyword">val</span> map_by_2</span> : <code class="type">f:('a -> 'a -> 'a) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Map objects two by two. lazily.
      The last element is kept in the sequence if the count is odd.<br>
<b>Since</b> 0.7<br>
</div>

<pre><span id="VALfor_all"><span class="keyword">val</span> for_all</span> : <code class="type">f:('a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Do all elements satisfy the predicate?<br>
</div>

<pre><span id="VALexists"><span class="keyword">val</span> exists</span> : <code class="type">f:('a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Exists there some element satisfying the predicate?<br>
</div>

<pre><span id="VALmem"><span class="keyword">val</span> mem</span> : <code class="type">?eq:('a -> 'a -> bool) -> x:'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Is the value a member of the sequence?<br>
<b>Since</b> 0.5<br>
</div>
<div class="param_info"><code class="code">eq</code> : the equality predicate to use (default <code class="code">(=)</code>)</div>

<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type">('a -> 'b option) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b option</code></pre><div class="info ">
Find the first element on which the function doesn't return <code class="code">None</code><br>
<b>Since</b> 0.5<br>
</div>

<pre><span id="VALfind_map"><span class="keyword">val</span> find_map</span> : <code class="type">f:('a -> 'b option) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b option</code></pre><div class="info ">
Alias to <a href="SequenceLabels.html#VALfind"><code class="code">SequenceLabels.find</code></a><br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALfindi"><span class="keyword">val</span> findi</span> : <code class="type">f:(int -> 'a -> 'b option) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b option</code></pre><div class="info ">
Indexed version of <a href="SequenceLabels.html#VALfind"><code class="code">SequenceLabels.find</code></a><br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALfind_mapi"><span class="keyword">val</span> find_mapi</span> : <code class="type">f:(int -> 'a -> 'b option) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b option</code></pre><div class="info ">
Alias to <a href="SequenceLabels.html#VALfindi"><code class="code">SequenceLabels.findi</code></a><br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALfind_pred"><span class="keyword">val</span> find_pred</span> : <code class="type">f:('a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a option</code></pre><div class="info ">
<code class="code">find_pred p l</code> finds the first element of <code class="code">l</code> that satisfies <code class="code">p</code>,
    or returns <code class="code">None</code> if no element satisfies <code class="code">p</code><br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALfind_pred_exn"><span class="keyword">val</span> find_pred_exn</span> : <code class="type">f:('a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Unsafe version of <a href="SequenceLabels.html#VALfind_pred"><code class="code">SequenceLabels.find_pred</code></a><br>
<b>Since</b> 0.9<br>
<b>Raises</b> <code>Not_found</code> if no such element is found<br>
</div>

<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> int</code></pre><div class="info ">
How long is the sequence? Forces the sequence.<br>
</div>

<pre><span id="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Is the sequence empty? Forces the sequence.<br>
</div>
<br>
<h2 id="2_Transformasequence">Transform a sequence</h2><br>

<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">f:('a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Filter on elements of the sequence<br>
</div>

<pre><span id="VALappend"><span class="keyword">val</span> append</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Append two sequences. Iterating on the result is like iterating
    on the first, then on the second.<br>
</div>

<pre><span id="VALappend_l"><span class="keyword">val</span> append_l</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> list -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Append sequences. Iterating on the result is like iterating
    on the each sequence of the list in order.<br>
<b>Since</b> 0.11<br>
</div>

<pre><span id="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Concatenate a sequence of sequences into one sequence.<br>
</div>

<pre><span id="VALflatten"><span class="keyword">val</span> flatten</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Alias for <a href="SequenceLabels.html#VALconcat"><code class="code">SequenceLabels.concat</code></a><br>
</div>

<pre><span id="VALflat_map"><span class="keyword">val</span> flat_map</span> : <code class="type">f:('a -> 'b <a href="SequenceLabels.html#TYPEt">t</a>) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Alias to <code class="code">flatMap</code> with a more explicit name<br>
</div>

<pre><span id="VALflat_map_l"><span class="keyword">val</span> flat_map_l</span> : <code class="type">f:('a -> 'b list) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Convenience function combining <a href="SequenceLabels.html#VALflat_map"><code class="code">SequenceLabels.flat_map</code></a> and <a href="SequenceLabels.html#VALof_list"><code class="code">SequenceLabels.of_list</code></a><br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">f:('a -> 'b option) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Alias to <code class="code">fmap</code> with a more explicit name<br>
</div>

<pre><span id="VALfilter_mapi"><span class="keyword">val</span> filter_mapi</span> : <code class="type">f:(int -> 'a -> 'b option) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Map with indices, and only keep non-<code class="code">None</code> elements<br>
<b>Since</b> 0.11<br>
</div>

<pre><span id="VALseq_list"><span class="keyword">val</span> seq_list</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> list -> 'a list <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">seq_list l</code> returns all the ways to pick one element in each sub-sequence
    in <code class="code">l</code>. Assumes the sub-sequences can be iterated on several times.<br>
<b>Since</b> 0.11<br>
</div>

<pre><span id="VALseq_list_map"><span class="keyword">val</span> seq_list_map</span> : <code class="type">f:('a -> 'b <a href="SequenceLabels.html#TYPEt">t</a>) -> 'a list -> 'b list <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">seq_list_map f l</code> maps <code class="code">f</code> over every element of <code class="code">l</code>,
    then calls <a href="SequenceLabels.html#VALseq_list"><code class="code">SequenceLabels.seq_list</code></a><br>
<b>Since</b> 0.11<br>
</div>

<pre><span id="VALintersperse"><span class="keyword">val</span> intersperse</span> : <code class="type">x:'a -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Insert the single element between every element of the sequence<br>
</div>
<br>
<h2 id="2_Caching">Caching</h2><br>

<pre><span id="VALpersistent"><span class="keyword">val</span> persistent</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Iterate on the sequence, storing elements in an efficient internal structure..
    The resulting sequence can be iterated on as many times as needed.
    <b>Note</b>: calling persistent on an already persistent sequence
    will still make a new copy of the sequence!<br>
</div>

<pre><span id="VALpersistent_lazy"><span class="keyword">val</span> persistent_lazy</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Lazy version of <a href="SequenceLabels.html#VALpersistent"><code class="code">SequenceLabels.persistent</code></a>. When calling <code class="code">persistent_lazy s</code>,
    a new sequence <code class="code">s'</code> is immediately returned (without actually consuming
    <code class="code">s</code>) in constant time; the first time <code class="code">s'</code> is iterated on,
    it also consumes <code class="code">s</code> and caches its content into a inner data
    structure that will back <code class="code">s'</code> for future iterations.
<p>

    <b>warning</b>: on the first traversal of <code class="code">s'</code>, if the traversal
    is interrupted prematurely (<a href="SequenceLabels.html#VALtake"><code class="code">SequenceLabels.take</code></a>, etc.) then <code class="code">s'</code> will not be
    memorized, and the next call to <code class="code">s'</code> will traverse <code class="code">s</code> again.<br>
</div>
<br>
<h2 id="2_Misc">Misc</h2><br>

<pre><span id="VALsort"><span class="keyword">val</span> sort</span> : <code class="type">?cmp:('a -> 'a -> int) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sort the sequence. Eager, O(n) ram and O(n ln(n)) time.
    It iterates on elements of the argument sequence immediately,
    before it sorts them.<br>
</div>

<pre><span id="VALsort_uniq"><span class="keyword">val</span> sort_uniq</span> : <code class="type">?cmp:('a -> 'a -> int) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sort the sequence and remove duplicates. Eager, same as <code class="code">sort</code><br>
</div>

<pre><span id="VALsorted"><span class="keyword">val</span> sorted</span> : <code class="type">?cmp:('a -> 'a -> int) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Checks whether the sequence is sorted. Eager, same as <a href="SequenceLabels.html#VALsort"><code class="code">SequenceLabels.sort</code></a>.<br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALgroup_succ_by"><span class="keyword">val</span> group_succ_by</span> : <code class="type">?eq:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a list <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Group equal consecutive elements.
    Formerly synonym to <code class="code">group</code>.<br>
<b>Since</b> 0.6<br>
</div>

<pre><span id="VALgroup_by"><span class="keyword">val</span> group_by</span> : <code class="type">?hash:('a -> int) -><br>       ?eq:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a list <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Group equal elements, disregarding their order of appearance.
    The result sequence is traversable as many times as required.
    precondition: for any <code class="code">x</code> and <code class="code">y</code>, if <code class="code">eq x y</code> then <code class="code">hash x=hash y</code> must hold.<br>
<b>Since</b> 0.6<br>
</div>

<pre><span id="VALcount"><span class="keyword">val</span> count</span> : <code class="type">?hash:('a -> int) -><br>       ?eq:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> ('a * int) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Map each distinct element to its number of occurrences in the whole seq.
    Similar to <code class="code">group_by seq |&gt; map (fun l-&gt;List.hd l, List.length l)</code><br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALuniq"><span class="keyword">val</span> uniq</span> : <code class="type">?eq:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Remove consecutive duplicate elements. Basically this is
    like <code class="code">fun seq -&gt; map List.hd (group seq)</code>.<br>
</div>

<pre><span id="VALproduct"><span class="keyword">val</span> product</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> ('a * 'b) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Cartesian product of the sequences. When calling <code class="code">product a b</code>,
    the caller <b>MUST</b> ensure that <code class="code">b</code> can be traversed as many times
    as required (several times), possibly by calling <a href="SequenceLabels.html#VALpersistent"><code class="code">SequenceLabels.persistent</code></a> on it
    beforehand.<br>
</div>

<pre><span id="VALdiagonal_l"><span class="keyword">val</span> diagonal_l</span> : <code class="type">'a list -> ('a * 'a) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
All pairs of distinct positions of the list. <code class="code">diagonal l</code> will
    return the sequence of all <code class="code">List.nth i l, List.nth j l</code> if <code class="code">i &lt; j</code>.<br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALdiagonal"><span class="keyword">val</span> diagonal</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> ('a * 'a) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
All pairs of distinct positions of the sequence.
    Iterates only once on the sequence, which must be finite.<br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALproduct2"><span class="keyword">val</span> product2</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> ('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a></code></pre><div class="info ">
Binary version of <a href="SequenceLabels.html#VALproduct"><code class="code">SequenceLabels.product</code></a>. Same requirements.<br>
<b>Since</b> 0.5<br>
</div>

<pre><span id="VALjoin"><span class="keyword">val</span> join</span> : <code class="type">join_row:('a -> 'b -> 'c option) -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> 'c <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">join ~join_row a b</code> combines every element of <code class="code">a</code> with every
    element of <code class="code">b</code> using <code class="code">join_row</code>. If <code class="code">join_row</code> returns None, then
    the two elements do not combine. Assume that <code class="code">b</code> allows for multiple
    iterations.<br>
</div>

<pre><span id="VALjoin_by"><span class="keyword">val</span> join_by</span> : <code class="type">?eq:'key <a href="SequenceLabels.html#TYPEequal">equal</a> -><br>       ?hash:'key <a href="SequenceLabels.html#TYPEhash">hash</a> -><br>       ('a -> 'key) -><br>       ('b -> 'key) -><br>       merge:('key -> 'a -> 'b -> 'c option) -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> 'c <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">join key1 key2 ~merge</code> is a binary operation
    that takes two sequences <code class="code">a</code> and <code class="code">b</code>, projects their
    elements resp. with <code class="code">key1</code> and <code class="code">key2</code>, and combine
    values <code class="code">(x,y)</code> from <code class="code">(a,b)</code> with the same <code class="code">key</code>
    using <code class="code">merge</code>. If <code class="code">merge</code> returns <code class="code">None</code>, the combination
    of values is discarded.
    precondition: for any <code class="code">x</code> and <code class="code">y</code>, if <code class="code">eq x y</code> then <code class="code">hash x=hash y</code> must hold.<br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALjoin_all_by"><span class="keyword">val</span> join_all_by</span> : <code class="type">?eq:'key <a href="SequenceLabels.html#TYPEequal">equal</a> -><br>       ?hash:'key <a href="SequenceLabels.html#TYPEhash">hash</a> -><br>       ('a -> 'key) -><br>       ('b -> 'key) -><br>       merge:('key -> 'a list -> 'b list -> 'c option) -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> 'c <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">join_all_by key1 key2 ~merge</code> is a binary operation
    that takes two sequences <code class="code">a</code> and <code class="code">b</code>, projects their
    elements resp. with <code class="code">key1</code> and <code class="code">key2</code>, and, for each key <code class="code">k</code>
    occurring in at least one of them:<ul>
<li>compute the list <code class="code">l1</code> of elements of <code class="code">a</code> that map to <code class="code">k</code></li>
<li>compute the list <code class="code">l2</code> of elements of <code class="code">b</code> that map to <code class="code">k</code></li>
<li>call <code class="code">merge k l1 l2</code>. If <code class="code">merge</code> returns <code class="code">None</code>, the combination
      of values is discarded, otherwise it returns <code class="code">Some c</code>
      and <code class="code">c</code> is inserted in the result.</li>
</ul>
<br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALgroup_join_by"><span class="keyword">val</span> group_join_by</span> : <code class="type">?eq:'a <a href="SequenceLabels.html#TYPEequal">equal</a> -><br>       ?hash:'a <a href="SequenceLabels.html#TYPEhash">hash</a> -><br>       ('b -> 'a) -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> ('a * 'b list) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">group_join_by key2</code> associates to every element <code class="code">x</code> of
    the first sequence, all the elements <code class="code">y</code> of the second
    sequence such that <code class="code">eq x (key y)</code>. Elements of the first
    sequences without corresponding values in the second one
    are mapped to <code class="code">[]</code>
    precondition: for any <code class="code">x</code> and <code class="code">y</code>, if <code class="code">eq x y</code> then <code class="code">hash x=hash y</code> must hold.<br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALinter"><span class="keyword">val</span> inter</span> : <code class="type">?eq:'a <a href="SequenceLabels.html#TYPEequal">equal</a> -><br>       ?hash:'a <a href="SequenceLabels.html#TYPEhash">hash</a> -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Intersection of two collections. Each element will occur at most once
    in the result. Eager.
    precondition: for any <code class="code">x</code> and <code class="code">y</code>, if <code class="code">eq x y</code> then <code class="code">hash x=hash y</code> must hold.<br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALunion"><span class="keyword">val</span> union</span> : <code class="type">?eq:'a <a href="SequenceLabels.html#TYPEequal">equal</a> -><br>       ?hash:'a <a href="SequenceLabels.html#TYPEhash">hash</a> -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Union of two collections. Each element will occur at most once
    in the result. Eager.
    precondition: for any <code class="code">x</code> and <code class="code">y</code>, if <code class="code">eq x y</code> then <code class="code">hash x=hash y</code> must hold.<br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALdiff"><span class="keyword">val</span> diff</span> : <code class="type">?eq:'a <a href="SequenceLabels.html#TYPEequal">equal</a> -><br>       ?hash:'a <a href="SequenceLabels.html#TYPEhash">hash</a> -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Set difference. Eager.<br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALsubset"><span class="keyword">val</span> subset</span> : <code class="type">?eq:'a <a href="SequenceLabels.html#TYPEequal">equal</a> -><br>       ?hash:'a <a href="SequenceLabels.html#TYPEhash">hash</a> -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">subset a b</code> returns <code class="code">true</code> if all elements of <code class="code">a</code> belong to <code class="code">b</code>. Eager.
    precondition: for any <code class="code">x</code> and <code class="code">y</code>, if <code class="code">eq x y</code> then <code class="code">hash x=hash y</code> must hold.<br>
<b>Since</b> 0.10<br>
</div>

<pre><span id="VALunfoldr"><span class="keyword">val</span> unfoldr</span> : <code class="type">('b -> ('a * 'b) option) -> 'b -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">unfoldr f b</code> will apply <code class="code">f</code> to <code class="code">b</code>. If it
    yields <code class="code">Some (x,b')</code> then <code class="code">x</code> is returned
    and unfoldr recurses with <code class="code">b'</code>.<br>
</div>

<pre><span id="VALscan"><span class="keyword">val</span> scan</span> : <code class="type">('b -> 'a -> 'b) -> 'b -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence of intermediate results<br>
</div>

<pre><span id="VALmax"><span class="keyword">val</span> max</span> : <code class="type">?lt:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a option</code></pre><div class="info ">
Max element of the sequence, using the given comparison function.<br>
<b>Returns</b> None if the sequence is empty, Some <code class="code">m</code> where <code class="code">m</code> is the maximal
    element otherwise<br>
</div>

<pre><span id="VALmax_exn"><span class="keyword">val</span> max_exn</span> : <code class="type">?lt:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Unsafe version of <a href="SequenceLabels.html#VALmax"><code class="code">SequenceLabels.max</code></a><br>
<b>Since</b> 0.10<br>
<b>Raises</b> <code>Not_found</code> if the sequence is empty<br>
</div>

<pre><span id="VALmin"><span class="keyword">val</span> min</span> : <code class="type">?lt:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a option</code></pre><div class="info ">
Min element of the sequence, using the given comparison function.
    see <a href="SequenceLabels.html#VALmax"><code class="code">SequenceLabels.max</code></a> for more details.<br>
</div>

<pre><span id="VALmin_exn"><span class="keyword">val</span> min_exn</span> : <code class="type">?lt:('a -> 'a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Unsafe version of <a href="SequenceLabels.html#VALmin"><code class="code">SequenceLabels.min</code></a><br>
<b>Since</b> 0.10<br>
<b>Raises</b> <code>Not_found</code> if the sequence is empty<br>
</div>

<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type">int <a href="SequenceLabels.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Sum of elements<br>
<b>Since</b> 0.11<br>
</div>

<pre><span id="VALsumf"><span class="keyword">val</span> sumf</span> : <code class="type">float <a href="SequenceLabels.html#TYPEt">t</a> -> float</code></pre><div class="info ">
Sum of elements, using Kahan summation<br>
<b>Since</b> 0.11<br>
</div>

<pre><span id="VALhead"><span class="keyword">val</span> head</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a option</code></pre><div class="info ">
First element, if any, otherwise <code class="code">None</code><br>
<b>Since</b> 0.5.1<br>
</div>

<pre><span id="VALhead_exn"><span class="keyword">val</span> head_exn</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
First element, if any, fails<br>
<b>Since</b> 0.5.1<br>
<b>Raises</b> <code>Invalid_argument</code> if the sequence is empty<br>
</div>

<pre><span id="VALtake"><span class="keyword">val</span> take</span> : <code class="type">int -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Take at most <code class="code">n</code> elements from the sequence. Works on infinite
    sequences.<br>
</div>

<pre><span id="VALtake_while"><span class="keyword">val</span> take_while</span> : <code class="type">f:('a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Take elements while they satisfy the predicate, then stops iterating.
    Will work on an infinite sequence <code class="code">s</code> if the predicate is false for at
    least one element of <code class="code">s</code>.<br>
</div>

<pre><span id="VALfold_while"><span class="keyword">val</span> fold_while</span> : <code class="type">f:('a -> 'b -> 'a * [ `Continue | `Stop ]) -><br>       init:'a -> 'b <a href="SequenceLabels.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Folds over elements of the sequence, stopping early if the accumulator
    returns <code class="code">('a, `Stop)</code><br>
<b>Since</b> 0.5.5<br>
</div>

<pre><span id="VALdrop"><span class="keyword">val</span> drop</span> : <code class="type">int -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Drop the <code class="code">n</code> first elements of the sequence. Lazy.<br>
</div>

<pre><span id="VALdrop_while"><span class="keyword">val</span> drop_while</span> : <code class="type">f:('a -> bool) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Predicate version of <a href="SequenceLabels.html#VALdrop"><code class="code">SequenceLabels.drop</code></a><br>
</div>

<pre><span id="VALrev"><span class="keyword">val</span> rev</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Reverse the sequence. O(n) memory and time, needs the
    sequence to be finite. The result is persistent and does
    not depend on the input being repeatable.<br>
</div>
<br>
<h2 id="2_Binarysequences">Binary sequences</h2><br>

<pre><span id="VALempty2"><span class="keyword">val</span> empty2</span> : <code class="type">('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a></code></pre>
<pre><span id="VALis_empty2"><span class="keyword">val</span> is_empty2</span> : <code class="type">('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> bool</code></pre>
<pre><span id="VALlength2"><span class="keyword">val</span> length2</span> : <code class="type">('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> int</code></pre>
<pre><span id="VALzip"><span class="keyword">val</span> zip</span> : <code class="type">('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> ('a * 'b) <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALunzip"><span class="keyword">val</span> unzip</span> : <code class="type">('a * 'b) <a href="SequenceLabels.html#TYPEt">t</a> -> ('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a></code></pre>
<pre><span id="VALzip_i"><span class="keyword">val</span> zip_i</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> (int, 'a) <a href="SequenceLabels.html#TYPEt2">t2</a></code></pre><div class="info ">
Zip elements of the sequence with their index in the sequence<br>
</div>

<pre><span id="VALfold2"><span class="keyword">val</span> fold2</span> : <code class="type">f:('c -> 'a -> 'b -> 'c) -> init:'c -> ('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> 'c</code></pre>
<pre><span id="VALiter2"><span class="keyword">val</span> iter2</span> : <code class="type">f:('a -> 'b -> unit) -> ('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> unit</code></pre>
<pre><span id="VALmap2"><span class="keyword">val</span> map2</span> : <code class="type">f:('a -> 'b -> 'c) -> ('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> 'c <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALmap2_2"><span class="keyword">val</span> map2_2</span> : <code class="type">('a -> 'b -> 'c) -><br>       ('a -> 'b -> 'd) -> ('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> ('c, 'd) <a href="SequenceLabels.html#TYPEt2">t2</a></code></pre><div class="info ">
<code class="code">map2_2 f g seq2</code> maps each <code class="code">x, y</code> of seq2 into <code class="code">f x y, g x y</code><br>
</div>
<br>
<h2 id="2_Basicdatastructuresconverters">Basic data structures converters</h2><br>

<pre><span id="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a list</code></pre><div class="info ">
Convert the sequence into a list. Preserves order of elements.
    This function is tail-recursive, but consumes 2*n memory.
    If order doesn't matter to you, consider <a href="SequenceLabels.html#VALto_rev_list"><code class="code">SequenceLabels.to_rev_list</code></a>.<br>
</div>

<pre><span id="VALto_rev_list"><span class="keyword">val</span> to_rev_list</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a list</code></pre><div class="info ">
Get the list of the reversed sequence (more efficient than <a href="SequenceLabels.html#VALto_list"><code class="code">SequenceLabels.to_list</code></a>)<br>
</div>

<pre><span id="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type">'a list -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALon_list"><span class="keyword">val</span> on_list</span> : <code class="type">('a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b <a href="SequenceLabels.html#TYPEt">t</a>) -> 'a list -> 'b list</code></pre><div class="info ">
<code class="code">on_list f l</code> is equivalent to <code class="code">to_list @@ f @@ of_list l</code>.<br>
<b>Since</b> 0.5.2<br>
</div>

<pre><span id="VALpair_with_idx"><span class="keyword">val</span> pair_with_idx</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> (int * 'a) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Similar to <a href="SequenceLabels.html#VALzip_i"><code class="code">SequenceLabels.zip_i</code></a> but returns a normal sequence of tuples<br>
<b>Since</b> 0.11<br>
</div>

<pre><span id="VALto_opt"><span class="keyword">val</span> to_opt</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a option</code></pre><div class="info ">
Alias to <a href="SequenceLabels.html#VALhead"><code class="code">SequenceLabels.head</code></a><br>
<b>Since</b> 0.5.1<br>
</div>

<pre><span id="VALto_array"><span class="keyword">val</span> to_array</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a array</code></pre><div class="info ">
Convert to an array. Currently not very efficient because
    an intermediate list is used.<br>
</div>

<pre><span id="VALof_array"><span class="keyword">val</span> of_array</span> : <code class="type">'a array -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALof_array_i"><span class="keyword">val</span> of_array_i</span> : <code class="type">'a array -> (int * 'a) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Elements of the array, with their index<br>
</div>

<pre><span id="VALof_array2"><span class="keyword">val</span> of_array2</span> : <code class="type">'a array -> (int, 'a) <a href="SequenceLabels.html#TYPEt2">t2</a></code></pre>
<pre><span id="VALarray_slice"><span class="keyword">val</span> array_slice</span> : <code class="type">'a array -> int -> int -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">array_slice a i j</code> Sequence of elements whose indexes range
    from <code class="code">i</code> to <code class="code">j</code><br>
</div>

<pre><span id="VALof_opt"><span class="keyword">val</span> of_opt</span> : <code class="type">'a option -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Iterate on 0 or 1 values.<br>
<b>Since</b> 0.5.1<br>
</div>

<pre><span id="VALof_stream"><span class="keyword">val</span> of_stream</span> : <code class="type">'a Stream.t -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence of elements of a stream (usable only once)<br>
</div>

<pre><span id="VALto_stream"><span class="keyword">val</span> to_stream</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a Stream.t</code></pre><div class="info ">
Convert to a stream. linear in memory and time (a copy is made in memory)<br>
</div>

<pre><span id="VALto_stack"><span class="keyword">val</span> to_stack</span> : <code class="type">'a Stack.t -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Push elements of the sequence on the stack<br>
</div>

<pre><span id="VALof_stack"><span class="keyword">val</span> of_stack</span> : <code class="type">'a Stack.t -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence of elements of the stack (same order as <code class="code">Stack.iter</code>)<br>
</div>

<pre><span id="VALto_queue"><span class="keyword">val</span> to_queue</span> : <code class="type">'a Queue.t -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Push elements of the sequence into the queue<br>
</div>

<pre><span id="VALof_queue"><span class="keyword">val</span> of_queue</span> : <code class="type">'a Queue.t -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence of elements contained in the queue, FIFO order<br>
</div>

<pre><span id="VALhashtbl_add"><span class="keyword">val</span> hashtbl_add</span> : <code class="type">('a, 'b) Hashtbl.t -> ('a * 'b) <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Add elements of the sequence to the hashtable, with
    Hashtbl.add<br>
</div>

<pre><span id="VALhashtbl_replace"><span class="keyword">val</span> hashtbl_replace</span> : <code class="type">('a, 'b) Hashtbl.t -> ('a * 'b) <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Add elements of the sequence to the hashtable, with
    Hashtbl.replace (erases conflicting bindings)<br>
</div>

<pre><span id="VALto_hashtbl"><span class="keyword">val</span> to_hashtbl</span> : <code class="type">('a * 'b) <a href="SequenceLabels.html#TYPEt">t</a> -> ('a, 'b) Hashtbl.t</code></pre><div class="info ">
Build a hashtable from a sequence of key/value pairs<br>
</div>

<pre><span id="VALto_hashtbl2"><span class="keyword">val</span> to_hashtbl2</span> : <code class="type">('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a> -> ('a, 'b) Hashtbl.t</code></pre><div class="info ">
Build a hashtable from a sequence of key/value pairs<br>
</div>

<pre><span id="VALof_hashtbl"><span class="keyword">val</span> of_hashtbl</span> : <code class="type">('a, 'b) Hashtbl.t -> ('a * 'b) <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence of key/value pairs from the hashtable<br>
</div>

<pre><span id="VALof_hashtbl2"><span class="keyword">val</span> of_hashtbl2</span> : <code class="type">('a, 'b) Hashtbl.t -> ('a, 'b) <a href="SequenceLabels.html#TYPEt2">t2</a></code></pre><div class="info ">
Sequence of key/value pairs from the hashtable<br>
</div>

<pre><span id="VALhashtbl_keys"><span class="keyword">val</span> hashtbl_keys</span> : <code class="type">('a, 'b) Hashtbl.t -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALhashtbl_values"><span class="keyword">val</span> hashtbl_values</span> : <code class="type">('a, 'b) Hashtbl.t -> 'b <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALof_str"><span class="keyword">val</span> of_str</span> : <code class="type">string -> char <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALto_str"><span class="keyword">val</span> to_str</span> : <code class="type">char <a href="SequenceLabels.html#TYPEt">t</a> -> string</code></pre>
<pre><span id="VALconcat_str"><span class="keyword">val</span> concat_str</span> : <code class="type">string <a href="SequenceLabels.html#TYPEt">t</a> -> string</code></pre><div class="info ">
Concatenate strings together, eagerly.
    Also see <a href="SequenceLabels.html#VALintersperse"><code class="code">SequenceLabels.intersperse</code></a> to add a separator.<br>
<b>Since</b> 0.5<br>
</div>

<pre><span id="EXCEPTIONOneShotSequence"><span class="keyword">exception</span> OneShotSequence</span></pre>
<div class="info ">
Raised when the user tries to iterate several times on
    a transient iterator<br>
</div>

<pre><span id="VALof_in_channel"><span class="keyword">val</span> of_in_channel</span> : <code class="type">Pervasives.in_channel -> char <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Iterates on characters of the input (can block when one
    iterates over the sequence). If you need to iterate
    several times on this sequence, use <a href="SequenceLabels.html#VALpersistent"><code class="code">SequenceLabels.persistent</code></a>.<br>
<b>Raises</b> <code>OneShotSequence</code> when used more than once.<br>
</div>

<pre><span id="VALto_buffer"><span class="keyword">val</span> to_buffer</span> : <code class="type">char <a href="SequenceLabels.html#TYPEt">t</a> -> Buffer.t -> unit</code></pre><div class="info ">
Copy content of the sequence into the buffer<br>
</div>

<pre><span id="VALint_range"><span class="keyword">val</span> int_range</span> : <code class="type">start:int -> stop:int -> int <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Iterator on integers in <code class="code">start...stop</code> by steps 1. Also see
    <code class="code">(--)</code> for an infix version.<br>
</div>

<pre><span id="VALint_range_dec"><span class="keyword">val</span> int_range_dec</span> : <code class="type">start:int -> stop:int -> int <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Iterator on decreasing integers in <code class="code">stop...start</code> by steps -1.
    See <code class="code">(--^)</code> for an infix version<br>
</div>

<pre><span id="VALint_range_by"><span class="keyword">val</span> int_range_by</span> : <code class="type">step:int -> start:int -> stop:int -> int <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">int_range_by ~step ~start:i ~stop:j</code> is the range starting at <code class="code">i</code>, including <code class="code">j</code>,
    where the difference between successive elements is <code class="code">step</code>.
    use a negative <code class="code">step</code> for a decreasing sequence.<br>
<b>Since</b> 0.9<br>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">step=0</code><br>
</div>

<pre><span id="VALbools"><span class="keyword">val</span> bools</span> : <code class="type">bool <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Iterates on <code class="code">true</code> and <code class="code">false</code><br>
<b>Since</b> 0.9<br>
</div>

<pre><span id="VALof_set"><span class="keyword">val</span> of_set</span> : <code class="type">(module Set.S with type elt = 'a and type t = 'b) -><br>       'b -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Convert the given set to a sequence. The set module must be provided.<br>
</div>

<pre><span id="VALto_set"><span class="keyword">val</span> to_set</span> : <code class="type">(module Set.S with type elt = 'a and type t = 'b) -><br>       'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'b</code></pre><div class="info ">
Convert the sequence to a set, given the proper set module<br>
</div>

<pre><span id="TYPEgen"><span class="keyword">type</span> <code class="type">'a</code> gen</span> = <code class="type">unit -> 'a option</code> </pre>


<pre><span id="TYPEklist"><span class="keyword">type</span> <code class="type">'a</code> klist</span> = <code class="type">unit -> [ `Cons of 'a * 'a <a href="SequenceLabels.html#TYPEklist">klist</a> | `Nil ]</code> </pre>


<pre><span id="VALof_gen"><span class="keyword">val</span> of_gen</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEgen">gen</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Traverse eagerly the generator and build a sequence from it<br>
</div>

<pre><span id="VALto_gen"><span class="keyword">val</span> to_gen</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEgen">gen</a></code></pre><div class="info ">
Make the sequence persistent (O(n)) and then iterate on it. Eager.<br>
</div>

<pre><span id="VALof_klist"><span class="keyword">val</span> of_klist</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEklist">klist</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Iterate on the lazy list<br>
</div>

<pre><span id="VALto_klist"><span class="keyword">val</span> to_klist</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEklist">klist</a></code></pre><div class="info ">
Make the sequence persistent and then iterate on it. Eager.<br>
</div>
<br>
<h2 id="2_Functorialconversionsbetweensetsandsequences">Functorial conversions between sets and sequences</h2><br>

<pre><span class="keyword">module</span> <a href="SequenceLabels.Set.html">Set</a>: <code class="code">sig</code> <a href="SequenceLabels.Set.html">..</a> <code class="code">end</code></pre><br>
<h2 id="2_Conversionbetweenmapsandsequences">Conversion between maps and sequences.</h2><br>

<pre><span class="keyword">module</span> <a href="SequenceLabels.Map.html">Map</a>: <code class="code">sig</code> <a href="SequenceLabels.Map.html">..</a> <code class="code">end</code></pre><br>
<h2 id="2_Infinitesequencesofrandomvalues">Infinite sequences of random values</h2><br>

<pre><span id="VALrandom_int"><span class="keyword">val</span> random_int</span> : <code class="type">int -> int <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Infinite sequence of random integers between 0 and
    the given higher bound (see Random.int)<br>
</div>

<pre><span id="VALrandom_bool"><span class="keyword">val</span> random_bool</span> : <code class="type">bool <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Infinite sequence of random bool values<br>
</div>

<pre><span id="VALrandom_float"><span class="keyword">val</span> random_float</span> : <code class="type">float -> float <a href="SequenceLabels.html#TYPEt">t</a></code></pre>
<pre><span id="VALrandom_array"><span class="keyword">val</span> random_array</span> : <code class="type">'a array -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Sequence of choices of an element in the array<br>
</div>

<pre><span id="VALrandom_list"><span class="keyword">val</span> random_list</span> : <code class="type">'a list -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
Infinite sequence of random elements of the list. Basically the
    same as <a href="SequenceLabels.html#VALrandom_array"><code class="code">SequenceLabels.random_array</code></a>.<br>
</div>

<pre><span id="VALshuffle"><span class="keyword">val</span> shuffle</span> : <code class="type">'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">shuffle seq</code> returns a perfect shuffle of <code class="code">seq</code>.
    Uses O(length seq) memory and time. Eager.<br>
<b>Since</b> 0.7<br>
</div>

<pre><span id="VALshuffle_buffer"><span class="keyword">val</span> shuffle_buffer</span> : <code class="type">n:int -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a <a href="SequenceLabels.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">shuffle_buffer n seq</code> returns a sequence of element of <code class="code">seq</code> in random
    order. The shuffling is not uniform. Uses O(n) memory.
<p>

    The first <code class="code">n</code> elements of the sequence are consumed immediately. The
    rest is consumed lazily.<br>
<b>Since</b> 0.7<br>
</div>
<br>
<h2 id="2_Sampling">Sampling</h2><br>

<pre><span id="VALsample"><span class="keyword">val</span> sample</span> : <code class="type">n:int -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> 'a array</code></pre><div class="info ">
<code class="code">sample n seq</code> returns k samples of <code class="code">seq</code>, with uniform probability.
      It will consume the sequence and use O(n) memory.
<p>

      It returns an array of size <code class="code">min (length seq) n</code>.<br>
<b>Since</b> 0.7<br>
</div>
<br>
<h2 id="2_Infixfunctions">Infix functions</h2><br>

<pre><span class="keyword">module</span> <a href="SequenceLabels.Infix.html">Infix</a>: <code class="code">sig</code> <a href="SequenceLabels.Infix.html">..</a> <code class="code">end</code></pre>
<pre><span class="keyword">include</span> <a href="SequenceLabels.Infix.html">SequenceLabels.Infix</a></pre>
<br>
<h2 id="2_Prettyprintingofsequences">Pretty printing of sequences</h2><br>

<pre><span id="VALpp_seq"><span class="keyword">val</span> pp_seq</span> : <code class="type">?sep:string -><br>       (Format.formatter -> 'a -> unit) -><br>       Format.formatter -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty print a sequence of <code class="code">'a</code>, using the given pretty printer
    to print each elements. An optional separator string can be provided.<br>
</div>

<pre><span id="VALpp_buf"><span class="keyword">val</span> pp_buf</span> : <code class="type">?sep:string -><br>       (Buffer.t -> 'a -> unit) -> Buffer.t -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Print into a buffer<br>
</div>

<pre><span id="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">?sep:string -> ('a -> string) -> 'a <a href="SequenceLabels.html#TYPEt">t</a> -> string</code></pre><div class="info ">
Print into a string<br>
</div>
<br>
<h2 id="2_BasicIO">Basic IO</h2>
<p>

    Very basic interface to manipulate files as sequence of chunks/lines. The
    sequences take care of opening and closing files properly; every time
    one iterates over a sequence, the file is opened/closed again.
<p>

    Example: copy a file <code class="code">"a"</code> into file <code class="code">"b"</code>, removing blank lines:
<p>

    <pre class="codepre"><code class="code">      Sequence.(IO.lines_of "a" |&gt; filter (fun l-&gt; l&lt;&gt; "") |&gt; IO.write_lines "b");;
    </code></pre>
<p>

    By chunks of <code class="code">4096</code> bytes:
<p>

    <pre class="codepre"><code class="code">      Sequence.IO.(chunks_of ~size:4096 "a" |&gt; write_to "b");;
    </code></pre>
<p>

    Read the lines of a file into a list:
<p>

    <pre class="codepre"><code class="code">      Sequence.IO.lines "a" |&gt; Sequence.to_list
    </code></pre><br>

<pre><span class="keyword">module</span> <a href="SequenceLabels.IO.html">IO</a>: <code class="code">sig</code> <a href="SequenceLabels.IO.html">..</a> <code class="code">end</code></pre></body></html>