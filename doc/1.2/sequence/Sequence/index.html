<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sequence (sequence.Sequence)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">sequence</a> &#x00BB; Sequence</nav><h1>Module <code>Sequence</code></h1></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../iter/Iter/index.html">Iter</a></code></span></summary><aside><p>The iterators are designed to allow easy transfer (mappings) between data structures, without defining <code>n^2</code> conversions between the <code>n</code> types. The implementation relies on the assumption that an iterator can be iterated on as many times as needed; this choice allows for high performance of many combinators. However, for transient iterators, the <a href="index.html#val-persistent"><code>persistent</code></a> function is provided, storing elements of a transient iterator in memory; the iterator can then be used several times (See further).</p><p>Note that some combinators also return iterators (e.g. <code>group</code>). The transformation is computed on the fly every time one iterates over the resulting iterator. If a transformation performs heavy computation, <a href="index.html#val-persistent"><code>persistent</code></a> can also be used as intermediate storage.</p><p>Most functions are <b>lazy</b>, i.e. they do not actually use their arguments until their result is iterated on. For instance, if one calls <a href="index.html#val-map"><code>map</code></a> on an iterator, one gets a new iterator, but nothing else happens until this new iterator is used (by folding or iterating on it).</p><p>If an iterator is built from an iteration function that is <b>repeatable</b> (i.e. calling it several times always iterates on the same set of elements, for instance List.iter or Map.iter), then the resulting <a href="index.html#type-t"><code>t</code></a> object is also repeatable. For <b>one-time iter functions</b> such as iteration on a file descriptor or a <code>Stream</code>, the <a href="index.html#val-persistent"><code>persistent</code></a> function can be used to iterate and store elements in a memory structure; the result is an iterator that iterates on the elements of this memory structure, cheaply and repeatably.</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> +'a t</code><code> = (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>An iterator of values of type <code>'a</code>. If you give it a function <code>'a -&gt; unit</code> it will be applied to every element of the iterator successively.</p></dd></dl><dl><dt class="spec type" id="type-iter"><a href="#type-iter" class="anchor"></a><code><span class="keyword">type</span> +'a iter</code><code> = <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt></dl><aside><p><b>NOTE</b> Type <code>('a, 'b) t2 = ('a -&gt; 'b -&gt; unit) -&gt; unit</code> has been removed and subsumed by <code>('a * 'b) t</code></p><dl><dt>since</dt><dd>1.0</dd></dl></aside><dl><dt class="spec type" id="type-equal"><a href="#type-equal" class="anchor"></a><code><span class="keyword">type</span> 'a equal</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec type" id="type-hash"><a href="#type-hash" class="anchor"></a><code><span class="keyword">type</span> 'a hash</code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt></dl><section><header><h2 id="creation"><a href="#creation" class="anchor"></a>Creation</h2></header><dl><dt class="spec value" id="val-from_iter"><a href="#val-from_iter" class="anchor"></a><code><span class="keyword">val</span> from_iter : ((<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build an iterator from a iter function</p></dd></dl><dl><dt class="spec value" id="val-from_labelled_iter"><a href="#val-from_labelled_iter" class="anchor"></a><code><span class="keyword">val</span> from_labelled_iter : (f:(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Build an iterator from a labelled iter function</p><dl><dt>since</dt><dd>NEXT_RELEASE</dd></dl></dd></dl><dl><dt class="spec value" id="val-from_fun"><a href="#val-from_fun" class="anchor"></a><code><span class="keyword">val</span> from_fun : (unit <span>&#45;&gt;</span> <span class="type-var">'a</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Call the function repeatedly until it returns None. This iterator is transient, use <a href="index.html#val-persistent"><code>persistent</code></a> if needed!</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Empty iterator. It contains no element.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">val</span> singleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Singleton iterator, with exactly one element.</p></dd></dl><dl><dt class="spec value" id="val-doubleton"><a href="#val-doubleton" class="anchor"></a><code><span class="keyword">val</span> doubleton : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator with exactly two elements</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : (int <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>init f</code> is the infinite iterator <code>f 0; f 1; f 2; …</code>.</p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val</span> cons : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cons x l</code> yields <code>x</code>, then yields from <code>l</code>. Same as <code>append (singleton x) l</code></p></dd></dl><dl><dt class="spec value" id="val-snoc"><a href="#val-snoc" class="anchor"></a><code><span class="keyword">val</span> snoc : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Same as <a href="index.html#val-cons"><code>cons</code></a> but yields the element after iterating on <code>l</code></p></dd></dl><dl><dt class="spec value" id="val-return"><a href="#val-return" class="anchor"></a><code><span class="keyword">val</span> return : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Synonym to <a href="index.html#val-singleton"><code>singleton</code></a></p></dd></dl><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">val</span> pure : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Synonym to <a href="index.html#val-singleton"><code>singleton</code></a></p></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Infinite iterator of the same element. You may want to look at <a href="index.html#val-take"><code>take</code></a> and the likes if you iterate on it.</p></dd></dl><dl><dt class="spec value" id="val-iterate"><a href="#val-iterate" class="anchor"></a><code><span class="keyword">val</span> iterate : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>iterate f x</code> is the infinite iterator <code>x, f(x), f(f(x)), ...</code></p></dd></dl><dl><dt class="spec value" id="val-forever"><a href="#val-forever" class="anchor"></a><code><span class="keyword">val</span> forever : (unit <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator that calls the given function to produce elements. The iterator may be transient (depending on the function), and definitely is infinite. You may want to use <a href="index.html#val-take"><code>take</code></a> and <a href="index.html#val-persistent"><code>persistent</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-cycle"><a href="#val-cycle" class="anchor"></a><code><span class="keyword">val</span> cycle : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Cycle forever through the given iterator. Assume the given iterator can be traversed any amount of times (not transient). This yields an infinite iterator, you should use something like <a href="index.html#val-take"><code>take</code></a> not to loop forever.</p></dd></dl><dl><dt class="spec value" id="val-unfoldr"><a href="#val-unfoldr" class="anchor"></a><code><span class="keyword">val</span> unfoldr : (<span class="type-var">'b</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) option) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unfoldr f b</code> will apply <code>f</code> to <code>b</code>. If it yields <code>Some (x,b')</code> then <code>x</code> is returned and unfoldr recurses with <code>b'</code>.</p></dd></dl><dl><dt class="spec value" id="val-scan"><a href="#val-scan" class="anchor"></a><code><span class="keyword">val</span> scan : (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator of intermediate results</p></dd></dl></section><section><header><h2 id="consumption"><a href="#consumption" class="anchor"></a>Consumption</h2></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Consume the iterator, passing all its arguments to the function. Basically <code>iter f seq</code> is just <code>seq f</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate on elements and their index in the iterator</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Fold over elements of the iterator, consuming it</p></dd></dl><dl><dt class="spec value" id="val-foldi"><a href="#val-foldi" class="anchor"></a><code><span class="keyword">val</span> foldi : (<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Fold over elements of the iterator and their index, consuming it</p></dd></dl><dl><dt class="spec value" id="val-fold_map"><a href="#val-fold_map" class="anchor"></a><code><span class="keyword">val</span> fold_map : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fold_map f acc l</code> is like <a href="index.html#val-map"><code>map</code></a>, but it carries some state as in <a href="index.html#val-fold"><code>fold</code></a>. The state is not returned, it is just used to thread some information to the map function.</p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-fold_filter_map"><a href="#val-fold_filter_map" class="anchor"></a><code><span class="keyword">val</span> fold_filter_map : (<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span> * <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>fold_filter_map f acc l</code> is a <a href="index.html#val-fold_map"><code>fold_map</code></a>-like function, but the function can choose to skip an element by retuning <code>None</code>.</p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map objects of the iterator into other elements, lazily</p></dd></dl><dl><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map objects, along with their index in the iterator</p></dd></dl><dl><dt class="spec value" id="val-map_by_2"><a href="#val-map_by_2" class="anchor"></a><code><span class="keyword">val</span> map_by_2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map objects two by two. lazily. The last element is kept in the iterator if the count is odd.</p><dl><dt>since</dt><dd>0.7</dd></dl></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Do all elements satisfy the predicate?</p></dd></dl><dl><dt class="spec value" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span class="keyword">val</span> exists : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Exists there some element satisfying the predicate?</p></dd></dl><dl><dt class="spec value" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span class="keyword">val</span> mem : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the value a member of the iterator?</p><dl><dt>parameter eq</dt><dd><p>the equality predicate to use (default <code>(=)</code>)</p></dd></dl><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Find the first element on which the function doesn't return <code>None</code></p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span class="keyword">val</span> find_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Alias to <a href="index.html#val-find"><code>find</code></a></p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-findi"><a href="#val-findi" class="anchor"></a><code><span class="keyword">val</span> findi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Indexed version of <a href="index.html#val-find"><code>find</code></a></p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_mapi"><a href="#val-find_mapi" class="anchor"></a><code><span class="keyword">val</span> find_mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> option</code></dt><dd><p>Alias to <a href="index.html#val-findi"><code>findi</code></a></p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_pred"><a href="#val-find_pred" class="anchor"></a><code><span class="keyword">val</span> find_pred : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p><code>find_pred p l</code> finds the first element of <code>l</code> that satisfies <code>p</code>, or returns <code>None</code> if no element satisfies <code>p</code></p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-find_pred_exn"><a href="#val-find_pred_exn" class="anchor"></a><code><span class="keyword">val</span> find_pred_exn : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Unsafe version of <a href="index.html#val-find_pred"><code>find_pred</code></a></p><dl><dt>raises Not_found</dt><dd><p>if no such element is found</p></dd></dl><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>How long is the iterator? Forces the iterator.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the iterator empty? Forces the iterator.</p></dd></dl></section><section><header><h2 id="transformation"><a href="#transformation" class="anchor"></a>Transformation</h2></header><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Filter on elements of the iterator</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Append two iterators. Iterating on the result is like iterating on the first, then on the second.</p></dd></dl><dl><dt class="spec value" id="val-append_l"><a href="#val-append_l" class="anchor"></a><code><span class="keyword">val</span> append_l : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Append iterators. Iterating on the result is like iterating on the each iterator of the list in order.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenate an iterator of iterators into one iterator.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Alias for <a href="index.html#val-concat"><code>concat</code></a></p></dd></dl><dl><dt class="spec value" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span class="keyword">val</span> flat_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Monadic bind. Intuitively, it applies the function to every element of the initial iterator, and calls <a href="index.html#val-concat"><code>concat</code></a>. Formerly <code>flatMap</code></p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-flat_map_l"><a href="#val-flat_map_l" class="anchor"></a><code><span class="keyword">val</span> flat_map_l : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> list) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convenience function combining <a href="index.html#val-flat_map"><code>flat_map</code></a> and <a href="index.html#val-of_list"><code>of_list</code></a></p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-seq_list"><a href="#val-seq_list" class="anchor"></a><code><span class="keyword">val</span> seq_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>seq_list l</code> returns all the ways to pick one element in each sub-iterator in <code>l</code>. Assumes the sub-iterators can be iterated on several times.</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-seq_list_map"><a href="#val-seq_list_map" class="anchor"></a><code><span class="keyword">val</span> seq_list_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <a href="index.html#type-t">t</a></code></dt><dd><p><code>seq_list_map f l</code> maps <code>f</code> over every element of <code>l</code>, then calls <a href="index.html#val-seq_list"><code>seq_list</code></a></p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map and only keep non-<code>None</code> elements Formerly <code>fmap</code></p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_mapi"><a href="#val-filter_mapi" class="anchor"></a><code><span class="keyword">val</span> filter_mapi : (int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Map with indices, and only keep non-<code>None</code> elements</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-filter_count"><a href="#val-filter_count" class="anchor"></a><code><span class="keyword">val</span> filter_count : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Count how many elements satisfy the given predicate</p><dl><dt>since</dt><dd>1.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-intersperse"><a href="#val-intersperse" class="anchor"></a><code><span class="keyword">val</span> intersperse : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Insert the single element between every element of the iterator</p></dd></dl><dl><dt class="spec value" id="val-keep_some"><a href="#val-keep_some" class="anchor"></a><code><span class="keyword">val</span> keep_some : <span class="type-var">'a</span> option <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>filter_some l</code> retains only elements of the form <code>Some x</code>. Same as <code>filter_map (fun x-&gt;x)</code></p><dl><dt>since</dt><dd>1.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-keep_ok"><a href="#val-keep_ok" class="anchor"></a><code><span class="keyword">val</span> keep_ok : (<span class="type-var">'a</span>, <span class="type-var">_</span>) Result.result <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keep_ok l</code> retains only elements of the form <code>Ok x</code>.</p><dl><dt>since</dt><dd>1.0</dd></dl></dd></dl><dl><dt class="spec value" id="val-keep_error"><a href="#val-keep_error" class="anchor"></a><code><span class="keyword">val</span> keep_error : (<span class="type-var">_</span>, <span class="type-var">'e</span>) Result.result <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'e</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>keep_error l</code> retains only elements of the form <code>Error x</code>.</p><dl><dt>since</dt><dd>1.0</dd></dl></dd></dl></section><section><header><h2 id="caching"><a href="#caching" class="anchor"></a>Caching</h2></header><dl><dt class="spec value" id="val-persistent"><a href="#val-persistent" class="anchor"></a><code><span class="keyword">val</span> persistent : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterate on the iterator, storing elements in an efficient internal structure.. The resulting iterator can be iterated on as many times as needed. <b>Note</b>: calling persistent on an already persistent iterator will still make a new copy of the iterator!</p></dd></dl><dl><dt class="spec value" id="val-persistent_lazy"><a href="#val-persistent_lazy" class="anchor"></a><code><span class="keyword">val</span> persistent_lazy : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Lazy version of <a href="index.html#val-persistent"><code>persistent</code></a>. When calling <code>persistent_lazy s</code>, a new iterator <code>s'</code> is immediately returned (without actually consuming <code>s</code>) in constant time; the first time <code>s'</code> is iterated on, it also consumes <code>s</code> and caches its content into a inner data structure that will back <code>s'</code> for future iterations.</p><p><b>warning</b>: on the first traversal of <code>s'</code>, if the traversal is interrupted prematurely (<a href="index.html#val-take"><code>take</code></a>, etc.) then <code>s'</code> will not be memorized, and the next call to <code>s'</code> will traverse <code>s</code> again.</p></dd></dl></section><section><header><h2 id="misc"><a href="#misc" class="anchor"></a>Misc</h2></header><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sort the iterator. Eager, O(n) ram and O(n ln(n)) time. It iterates on elements of the argument iterator immediately, before it sorts them.</p></dd></dl><dl><dt class="spec value" id="val-sort_uniq"><a href="#val-sort_uniq" class="anchor"></a><code><span class="keyword">val</span> sort_uniq : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Sort the iterator and remove duplicates. Eager, same as <code>sort</code></p></dd></dl><dl><dt class="spec value" id="val-sorted"><a href="#val-sorted" class="anchor"></a><code><span class="keyword">val</span> sorted : ?&#8288;cmp:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Checks whether the iterator is sorted. Eager, same as <a href="index.html#val-sort"><code>sort</code></a>.</p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_succ_by"><a href="#val-group_succ_by" class="anchor"></a><code><span class="keyword">val</span> group_succ_by : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Group equal consecutive elements. Linear time. Formerly synonym to <code>group</code>.</p><dl><dt>since</dt><dd>0.6</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_by"><a href="#val-group_by" class="anchor"></a><code><span class="keyword">val</span> group_by : ?&#8288;hash:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></dt><dd><p>Group equal elements, disregarding their order of appearance. The result iterator is traversable as many times as required. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>0.6</dd></dl></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : ?&#8288;hash:(<span class="type-var">'a</span> <span>&#45;&gt;</span> int) <span>&#45;&gt;</span> ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * int) <a href="index.html#type-t">t</a></code></dt><dd><p>Map each distinct element to its number of occurrences in the whole seq. Similar to <code>group_by seq |&gt; map (fun l-&gt;List.hd l, List.length l)</code> precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-uniq"><a href="#val-uniq" class="anchor"></a><code><span class="keyword">val</span> uniq : ?&#8288;eq:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Remove consecutive duplicate elements. Basically this is like <code>fun seq -&gt; map List.hd (group seq)</code>.</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Cartesian product of iterators. When calling <code>product a b</code>, the caller <b>MUST</b> ensure that <code>b</code> can be traversed as many times as required (several times), possibly by calling <a href="index.html#val-persistent"><code>persistent</code></a> on it beforehand.</p></dd></dl><dl><dt class="spec value" id="val-diagonal_l"><a href="#val-diagonal_l" class="anchor"></a><code><span class="keyword">val</span> diagonal_l : <span class="type-var">'a</span> list <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>All pairs of distinct positions of the list. <code>diagonal l</code> will return the iterator of all <code>List.nth i l, List.nth j l</code> if <code>i &lt; j</code>.</p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-diagonal"><a href="#val-diagonal" class="anchor"></a><code><span class="keyword">val</span> diagonal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>All pairs of distinct positions of the iterator. Iterates only once on the iterator, which must be finite.</p><dl><dt>since</dt><dd>0.9</dd></dl></dd></dl><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : join_row:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join ~join_row a b</code> combines every element of <code>a</code> with every element of <code>b</code> using <code>join_row</code>. If <code>join_row</code> returns None, then the two elements do not combine. Assume that <code>b</code> allows for multiple iterations.</p></dd></dl><dl><dt class="spec value" id="val-join_by"><a href="#val-join_by" class="anchor"></a><code><span class="keyword">val</span> join_by : ?&#8288;eq:<span class="type-var">'key</span> <a href="index.html#type-equal">equal</a> <span>&#45;&gt;</span> ?&#8288;hash:<span class="type-var">'key</span> <a href="index.html#type-hash">hash</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> merge:(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join key1 key2 ~merge</code> is a binary operation that takes two iterators <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and combine values <code>(x,y)</code> from <code>(a,b)</code> with the same <code>key</code> using <code>merge</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-join_all_by"><a href="#val-join_all_by" class="anchor"></a><code><span class="keyword">val</span> join_all_by : ?&#8288;eq:<span class="type-var">'key</span> <a href="index.html#type-equal">equal</a> <span>&#45;&gt;</span> ?&#8288;hash:<span class="type-var">'key</span> <a href="index.html#type-hash">hash</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'key</span>) <span>&#45;&gt;</span> merge:(<span class="type-var">'key</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list <span>&#45;&gt;</span> <span class="type-var">'c</span> option) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>join_all_by key1 key2 ~merge</code> is a binary operation that takes two iterators <code>a</code> and <code>b</code>, projects their elements resp. with <code>key1</code> and <code>key2</code>, and, for each key <code>k</code> occurring in at least one of them:</p><ul><li>compute the list <code>l1</code> of elements of <code>a</code> that map to <code>k</code></li><li>compute the list <code>l2</code> of elements of <code>b</code> that map to <code>k</code></li><li>call <code>merge k l1 l2</code>. If <code>merge</code> returns <code>None</code>, the combination of values is discarded, otherwise it returns <code>Some c</code> and <code>c</code> is inserted in the result.</li></ul><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-group_join_by"><a href="#val-group_join_by" class="anchor"></a><code><span class="keyword">val</span> group_join_by : ?&#8288;eq:<span class="type-var">'a</span> <a href="index.html#type-equal">equal</a> <span>&#45;&gt;</span> ?&#8288;hash:<span class="type-var">'a</span> <a href="index.html#type-hash">hash</a> <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span> list) <a href="index.html#type-t">t</a></code></dt><dd><p><code>group_join_by key2</code> associates to every element <code>x</code> of the first iterator, all the elements <code>y</code> of the second iterator such that <code>eq x (key y)</code>. Elements of the first iterators without corresponding values in the second one are mapped to <code>[]</code> precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><section><header><h3 id="set-like"><a href="#set-like" class="anchor"></a>Set-like</h3></header><dl><dt class="spec value" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span class="keyword">val</span> inter : ?&#8288;eq:<span class="type-var">'a</span> <a href="index.html#type-equal">equal</a> <span>&#45;&gt;</span> ?&#8288;hash:<span class="type-var">'a</span> <a href="index.html#type-hash">hash</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Intersection of two collections. Each element will occur at most once in the result. Eager. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">val</span> union : ?&#8288;eq:<span class="type-var">'a</span> <a href="index.html#type-equal">equal</a> <span>&#45;&gt;</span> ?&#8288;hash:<span class="type-var">'a</span> <a href="index.html#type-hash">hash</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Union of two collections. Each element will occur at most once in the result. Eager. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">val</span> diff : ?&#8288;eq:<span class="type-var">'a</span> <a href="index.html#type-equal">equal</a> <span>&#45;&gt;</span> ?&#8288;hash:<span class="type-var">'a</span> <a href="index.html#type-hash">hash</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set difference. Eager.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">val</span> subset : ?&#8288;eq:<span class="type-var">'a</span> <a href="index.html#type-equal">equal</a> <span>&#45;&gt;</span> ?&#8288;hash:<span class="type-var">'a</span> <a href="index.html#type-hash">hash</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>subset a b</code> returns <code>true</code> if all elements of <code>a</code> belong to <code>b</code>. Eager. precondition: for any <code>x</code> and <code>y</code>, if <code>eq x y</code> then <code>hash x=hash y</code> must hold.</p><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl></section><section><header><h3 id="arithmetic"><a href="#arithmetic" class="anchor"></a>Arithmetic</h3></header><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : ?&#8288;lt:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Max element of the iterator, using the given comparison function.</p><dl><dt>returns</dt><dd><p>None if the iterator is empty, Some <code>m</code> where <code>m</code> is the maximal element otherwise</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-max_exn"><a href="#val-max_exn" class="anchor"></a><code><span class="keyword">val</span> max_exn : ?&#8288;lt:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Unsafe version of <a href="index.html#val-max"><code>max</code></a></p><dl><dt>raises Not_found</dt><dd><p>if the iterator is empty</p></dd></dl><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : ?&#8288;lt:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Min element of the iterator, using the given comparison function. see <a href="index.html#val-max"><code>max</code></a> for more details.</p></dd></dl><dl><dt class="spec value" id="val-min_exn"><a href="#val-min_exn" class="anchor"></a><code><span class="keyword">val</span> min_exn : ?&#8288;lt:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Unsafe version of <a href="index.html#val-min"><code>min</code></a></p><dl><dt>raises Not_found</dt><dd><p>if the iterator is empty</p></dd></dl><dl><dt>since</dt><dd>0.10</dd></dl></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : int <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Sum of elements</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-sumf"><a href="#val-sumf" class="anchor"></a><code><span class="keyword">val</span> sumf : float <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Sum of elements, using Kahan summation</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl></section><section><header><h3 id="list-like"><a href="#list-like" class="anchor"></a>List-like</h3></header><dl><dt class="spec value" id="val-head"><a href="#val-head" class="anchor"></a><code><span class="keyword">val</span> head : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>First element, if any, otherwise <code>None</code></p><dl><dt>since</dt><dd>0.5.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-head_exn"><a href="#val-head_exn" class="anchor"></a><code><span class="keyword">val</span> head_exn : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>First element, if any, fails</p><dl><dt>raises Invalid_argument</dt><dd><p>if the iterator is empty</p></dd></dl><dl><dt>since</dt><dd>0.5.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Take at most <code>n</code> elements from the iterator. Works on infinite iterators.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Take elements while they satisfy the predicate, then stops iterating. Will work on an infinite iterator <code>s</code> if the predicate is false for at least one element of <code>s</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_while"><a href="#val-fold_while" class="anchor"></a><code><span class="keyword">val</span> fold_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * [ `Stop | `Continue ]) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Folds over elements of the iterator, stopping early if the accumulator returns <code>('a, `Stop)</code></p><dl><dt>since</dt><dd>0.5.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Drop the <code>n</code> first elements of the iterator. Lazy.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : (<span class="type-var">'a</span> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Predicate version of <a href="index.html#val-drop"><code>drop</code></a></p></dd></dl><dl><dt class="spec value" id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val</span> rev : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Reverse the iterator. O(n) memory and time, needs the iterator to be finite. The result is persistent and does not depend on the input being repeatable.</p></dd></dl><dl><dt class="spec value" id="val-zip_i"><a href="#val-zip_i" class="anchor"></a><code><span class="keyword">val</span> zip_i : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Zip elements of the iterator with their index in the iterator.</p><dl><dt>since</dt><dd>1.0 Changed type to just give an iterator of pairs</dd></dl></dd></dl></section><section><header><h3 id="pair-iterators"><a href="#pair-iterators" class="anchor"></a>Pair iterators</h3></header><dl><dt class="spec value" id="val-fold2"><a href="#val-fold2" class="anchor"></a><code><span class="keyword">val</span> fold2 : (<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dt class="spec value" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span class="keyword">val</span> iter2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">val</span> map2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-map2_2"><a href="#val-map2_2" class="anchor"></a><code><span class="keyword">val</span> map2_2 : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'c</span> * <span class="type-var">'d</span>) <a href="index.html#type-t">t</a></code></dt><dd><p><code>map2_2 f g seq2</code> maps each <code>x, y</code> of seq2 into <code>f x y, g x y</code></p></dd></dl></section></section><section><header><h2 id="data-structures-converters"><a href="#data-structures-converters" class="anchor"></a>Data structures converters</h2></header><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Convert the iterator into a list. Preserves order of elements. This function is tail-recursive, but consumes 2*n memory. If order doesn't matter to you, consider <a href="index.html#val-to_rev_list"><code>to_rev_list</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-to_rev_list"><a href="#val-to_rev_list" class="anchor"></a><code><span class="keyword">val</span> to_rev_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Get the list of the reversed iterator (more efficient than <a href="index.html#val-to_list"><code>to_list</code></a>)</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-on_list"><a href="#val-on_list" class="anchor"></a><code><span class="keyword">val</span> on_list : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'b</span> list</code></dt><dd><p><code>on_list f l</code> is equivalent to <code>to_list @@ f @@ of_list l</code>.</p><dl><dt>since</dt><dd>0.5.2</dd></dl></dd></dl><dl><dt class="spec value" id="val-pair_with_idx"><a href="#val-pair_with_idx" class="anchor"></a><code><span class="keyword">val</span> pair_with_idx : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (int * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Similar to <a href="index.html#val-zip_i"><code>zip_i</code></a> but returns a normal iterator of tuples</p><dl><dt>since</dt><dd>0.11</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_opt"><a href="#val-to_opt" class="anchor"></a><code><span class="keyword">val</span> to_opt : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Alias to <a href="index.html#val-head"><code>head</code></a></p><dl><dt>since</dt><dd>0.5.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dd><p>Convert to an array. Currently not very efficient because an intermediate list is used.</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_array_i"><a href="#val-of_array_i" class="anchor"></a><code><span class="keyword">val</span> of_array_i : <span class="type-var">'a</span> array <span>&#45;&gt;</span> (int * <span class="type-var">'a</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Elements of the array, with their index</p></dd></dl><dl><dt class="spec value" id="val-array_slice"><a href="#val-array_slice" class="anchor"></a><code><span class="keyword">val</span> array_slice : <span class="type-var">'a</span> array <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>array_slice a i j</code> Iterator of elements whose indexes range from <code>i</code> to <code>j</code></p></dd></dl><dl><dt class="spec value" id="val-of_opt"><a href="#val-of_opt" class="anchor"></a><code><span class="keyword">val</span> of_opt : <span class="type-var">'a</span> option <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterate on 0 or 1 values.</p><dl><dt>since</dt><dd>0.5.1</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_stream"><a href="#val-of_stream" class="anchor"></a><code><span class="keyword">val</span> of_stream : <span class="type-var">'a</span> Stream.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator of elements of a stream (usable only once)</p></dd></dl><dl><dt class="spec value" id="val-to_stream"><a href="#val-to_stream" class="anchor"></a><code><span class="keyword">val</span> to_stream : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> Stream.t</code></dt><dd><p>Convert to a stream. linear in memory and time (a copy is made in memory)</p></dd></dl><dl><dt class="spec value" id="val-to_stack"><a href="#val-to_stack" class="anchor"></a><code><span class="keyword">val</span> to_stack : <span class="type-var">'a</span> Stack.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Push elements of the iterator on the stack</p></dd></dl><dl><dt class="spec value" id="val-of_stack"><a href="#val-of_stack" class="anchor"></a><code><span class="keyword">val</span> of_stack : <span class="type-var">'a</span> Stack.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator of elements of the stack (same order as <code>Stack.iter</code>)</p></dd></dl><dl><dt class="spec value" id="val-to_queue"><a href="#val-to_queue" class="anchor"></a><code><span class="keyword">val</span> to_queue : <span class="type-var">'a</span> Queue.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Push elements of the iterator into the queue</p></dd></dl><dl><dt class="spec value" id="val-of_queue"><a href="#val-of_queue" class="anchor"></a><code><span class="keyword">val</span> of_queue : <span class="type-var">'a</span> Queue.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator of elements contained in the queue, FIFO order</p></dd></dl><dl><dt class="spec value" id="val-hashtbl_add"><a href="#val-hashtbl_add" class="anchor"></a><code><span class="keyword">val</span> hashtbl_add : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Hashtbl.t <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add elements of the iterator to the hashtable, with Hashtbl.add</p></dd></dl><dl><dt class="spec value" id="val-hashtbl_replace"><a href="#val-hashtbl_replace" class="anchor"></a><code><span class="keyword">val</span> hashtbl_replace : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Hashtbl.t <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Add elements of the iterator to the hashtable, with Hashtbl.replace (erases conflicting bindings)</p></dd></dl><dl><dt class="spec value" id="val-to_hashtbl"><a href="#val-to_hashtbl" class="anchor"></a><code><span class="keyword">val</span> to_hashtbl : (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Hashtbl.t</code></dt><dd><p>Build a hashtable from an iterator of key/value pairs</p></dd></dl><dl><dt class="spec value" id="val-of_hashtbl"><a href="#val-of_hashtbl" class="anchor"></a><code><span class="keyword">val</span> of_hashtbl : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Hashtbl.t <span>&#45;&gt;</span> (<span class="type-var">'a</span> * <span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator of key/value pairs from the hashtable</p></dd></dl><dl><dt class="spec value" id="val-hashtbl_keys"><a href="#val-hashtbl_keys" class="anchor"></a><code><span class="keyword">val</span> hashtbl_keys : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Hashtbl.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-hashtbl_values"><a href="#val-hashtbl_values" class="anchor"></a><code><span class="keyword">val</span> hashtbl_values : (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Hashtbl.t <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_str"><a href="#val-of_str" class="anchor"></a><code><span class="keyword">val</span> of_str : string <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_str"><a href="#val-to_str" class="anchor"></a><code><span class="keyword">val</span> to_str : char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-concat_str"><a href="#val-concat_str" class="anchor"></a><code><span class="keyword">val</span> concat_str : string <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Concatenate strings together, eagerly. Also see <a href="index.html#val-intersperse"><code>intersperse</code></a> to add a separator.</p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec exception" id="exception-OneShotSequence"><a href="#exception-OneShotSequence" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">OneShotSequence</span></code></dt><dd><p>Raised when the user tries to iterate several times on a transient iterator</p></dd></dl><dl><dt class="spec value" id="val-of_in_channel"><a href="#val-of_in_channel" class="anchor"></a><code><span class="keyword">val</span> of_in_channel : Pervasives.in_channel <span>&#45;&gt;</span> char <a href="index.html#type-t">t</a></code></dt><dd><p>Iterates on characters of the input (can block when one iterates over the iterator). If you need to iterate several times on this iterator, use <a href="index.html#val-persistent"><code>persistent</code></a>.</p><dl><dt>raises OneShotIterator</dt><dd><p>when used more than once.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_buffer"><a href="#val-to_buffer" class="anchor"></a><code><span class="keyword">val</span> to_buffer : char <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Buffer.t <span>&#45;&gt;</span> unit</code></dt><dd><p>Copy content of the iterator into the buffer</p></dd></dl><dl><dt class="spec value" id="val-int_range"><a href="#val-int_range" class="anchor"></a><code><span class="keyword">val</span> int_range : start:int <span>&#45;&gt;</span> stop:int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator on integers in <code>start...stop</code> by steps 1. Also see <a href="index.html#val-(--)"><code>(--)</code></a> for an infix version.</p></dd></dl><dl><dt class="spec value" id="val-int_range_dec"><a href="#val-int_range_dec" class="anchor"></a><code><span class="keyword">val</span> int_range_dec : start:int <span>&#45;&gt;</span> stop:int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator on decreasing integers in <code>stop...start</code> by steps -1. See <a href="index.html#val-(--^)"><code>(--^)</code></a> for an infix version</p></dd></dl><dl><dt class="spec value" id="val-int_range_by"><a href="#val-int_range_by" class="anchor"></a><code><span class="keyword">val</span> int_range_by : step:int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>int_range_by ~step i j</code> is the range starting at <code>i</code>, including <code>j</code>, where the difference between successive elements is <code>step</code>. use a negative <code>step</code> for a decreasing iterator.</p><dl><dt>raises Invalid_argument</dt><dd><p>if <code>step=0</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-bools"><a href="#val-bools" class="anchor"></a><code><span class="keyword">val</span> bools : bool <a href="index.html#type-t">t</a></code></dt><dd><p>Iterates on <code>true</code> and <code>false</code></p><dl><dt>since</dt><dd>0.7</dd></dl></dd></dl><dl><dt class="spec value" id="val-of_set"><a href="#val-of_set" class="anchor"></a><code><span class="keyword">val</span> of_set : (<span class="keyword">module</span> Set.S <span class="keyword">with</span> <span class="keyword">type</span> elt = <span class="type-var">'a</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Convert the given set to an iterator. The set module must be provided.</p></dd></dl><dl><dt class="spec value" id="val-to_set"><a href="#val-to_set" class="anchor"></a><code><span class="keyword">val</span> to_set : (<span class="keyword">module</span> Set.S <span class="keyword">with</span> <span class="keyword">type</span> elt = <span class="type-var">'a</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Convert the iterator to a set, given the proper set module</p></dd></dl><dl><dt class="spec type" id="type-gen"><a href="#type-gen" class="anchor"></a><code><span class="keyword">type</span> 'a gen</code><code> = unit <span>&#45;&gt;</span> <span class="type-var">'a</span> option</code></dt><dt class="spec type" id="type-klist"><a href="#type-klist" class="anchor"></a><code><span class="keyword">type</span> 'a klist</code><code> = unit <span>&#45;&gt;</span> [ `Nil | `Cons of <span class="type-var">'a</span> * <span class="type-var">'a</span> <a href="index.html#type-klist">klist</a> ]</code></dt></dl><dl><dt class="spec value" id="val-of_gen"><a href="#val-of_gen" class="anchor"></a><code><span class="keyword">val</span> of_gen : <span class="type-var">'a</span> <a href="index.html#type-gen">gen</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Traverse eagerly the generator and build an iterator from it</p></dd></dl><dl><dt class="spec value" id="val-to_gen"><a href="#val-to_gen" class="anchor"></a><code><span class="keyword">val</span> to_gen : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-gen">gen</a></code></dt><dd><p>Make the iterator persistent (O(n)) and then iterate on it. Eager.</p></dd></dl><dl><dt class="spec value" id="val-of_klist"><a href="#val-of_klist" class="anchor"></a><code><span class="keyword">val</span> of_klist : <span class="type-var">'a</span> <a href="index.html#type-klist">klist</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterate on the lazy list</p></dd></dl><dl><dt class="spec value" id="val-to_klist"><a href="#val-to_klist" class="anchor"></a><code><span class="keyword">val</span> to_klist : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-klist">klist</a></code></dt><dd><p>Make the iterator persistent and then iterate on it. Eager.</p></dd></dl><section><header><h3 id="sets"><a href="#sets" class="anchor"></a>Sets</h3></header><div class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> Set = <a href="../../iter/Iter/index.html#module-Set">Iter.Set</a></code></div></section><section><header><h3 id="maps"><a href="#maps" class="anchor"></a>Maps</h3></header><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> Map = <a href="../../iter/Iter/index.html#module-Map">Iter.Map</a></code></div></section></section><section><header><h2 id="random-iterators"><a href="#random-iterators" class="anchor"></a>Random iterators</h2></header><dl><dt class="spec value" id="val-random_int"><a href="#val-random_int" class="anchor"></a><code><span class="keyword">val</span> random_int : int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p>Infinite iterator of random integers between 0 and the given higher bound (see Random.int)</p></dd></dl><dl><dt class="spec value" id="val-random_bool"><a href="#val-random_bool" class="anchor"></a><code><span class="keyword">val</span> random_bool : bool <a href="index.html#type-t">t</a></code></dt><dd><p>Infinite iterator of random bool values</p></dd></dl><dl><dt class="spec value" id="val-random_float"><a href="#val-random_float" class="anchor"></a><code><span class="keyword">val</span> random_float : float <span>&#45;&gt;</span> float <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-random_array"><a href="#val-random_array" class="anchor"></a><code><span class="keyword">val</span> random_array : <span class="type-var">'a</span> array <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Iterator of choices of an element in the array</p></dd></dl><dl><dt class="spec value" id="val-random_list"><a href="#val-random_list" class="anchor"></a><code><span class="keyword">val</span> random_list : <span class="type-var">'a</span> list <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Infinite iterator of random elements of the list. Basically the same as <a href="index.html#val-random_array"><code>random_array</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span class="keyword">val</span> shuffle : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>shuffle seq</code> returns a perfect shuffle of <code>seq</code>. Uses O(length seq) memory and time. Eager.</p><dl><dt>since</dt><dd>0.7</dd></dl></dd></dl><dl><dt class="spec value" id="val-shuffle_buffer"><a href="#val-shuffle_buffer" class="anchor"></a><code><span class="keyword">val</span> shuffle_buffer : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>shuffle_buffer n seq</code> returns an iterator of element of <code>seq</code> in random order. The shuffling is *not* uniform. Uses O(n) memory.</p><p>The first <code>n</code> elements of the iterator are consumed immediately. The rest is consumed lazily.</p><dl><dt>since</dt><dd>0.7</dd></dl></dd></dl><section><header><h3 id="sampling"><a href="#sampling" class="anchor"></a>Sampling</h3></header><dl><dt class="spec value" id="val-sample"><a href="#val-sample" class="anchor"></a><code><span class="keyword">val</span> sample : int <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> array</code></dt><dd><p><code>sample n seq</code> returns k samples of <code>seq</code>, with uniform probability. It will consume the iterator and use O(n) memory.</p><p>It returns an array of size <code>min (length seq) n</code>.</p><dl><dt>since</dt><dd>0.7</dd></dl></dd></dl></section></section><section><header><h2 id="infix-functions"><a href="#infix-functions" class="anchor"></a>Infix functions</h2></header><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> Infix = <a href="../../iter/Iter/index.html#module-Infix">Iter.Infix</a></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="index.html#module-Infix">Infix</a></code></span></summary><dl><dt class="spec value" id="val-(--)"><a href="#val-(--)" class="anchor"></a><code><span class="keyword">val</span> (--) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>a -- b</code> is the range of integers from <code>a</code> to <code>b</code>, both included, in increasing order. It will therefore be empty if <code>a &gt; b</code>.</p></dd></dl><dl><dt class="spec value" id="val-(--^)"><a href="#val-(--^)" class="anchor"></a><code><span class="keyword">val</span> (--^) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <a href="index.html#type-t">t</a></code></dt><dd><p><code>a --^ b</code> is the range of integers from <code>b</code> to <code>a</code>, both included, in decreasing order (starts from <code>a</code>). It will therefore be empty if <code>a &lt; b</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Monadic bind (infix version of <a href="index.html#val-flat_map"><code>flat_map</code></a></p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-(&gt;|=)"><a href="#val-(&gt;|=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;|=) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Infix version of <a href="index.html#val-map"><code>map</code></a></p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Applicative operator (product+application)</p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl><dl><dt class="spec value" id="val-(&lt;+&gt;)"><a href="#val-(&lt;+&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;+&gt;) : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Concatenation of iterators</p><dl><dt>since</dt><dd>0.5</dd></dl></dd></dl></details></div></div></div></section><section><header><h2 id="pretty-printing"><a href="#pretty-printing" class="anchor"></a>Pretty printing</h2></header><dl><dt class="spec value" id="val-pp_seq"><a href="#val-pp_seq" class="anchor"></a><code><span class="keyword">val</span> pp_seq : ?&#8288;sep:string <span>&#45;&gt;</span> (Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty print an iterator of <code>'a</code>, using the given pretty printer to print each elements. An optional separator string can be provided.</p></dd></dl><dl><dt class="spec value" id="val-pp_buf"><a href="#val-pp_buf" class="anchor"></a><code><span class="keyword">val</span> pp_buf : ?&#8288;sep:string <span>&#45;&gt;</span> (Buffer.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> Buffer.t <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print into a buffer</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : ?&#8288;sep:string <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> string) <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>Print into a string</p></dd></dl></section><section><header><h2 id="basic-io"><a href="#basic-io" class="anchor"></a>Basic IO</h2><p>Very basic interface to manipulate files as iterator of chunks/lines. The iterators take care of opening and closing files properly; every time one iterates over an iterator, the file is opened/closed again.</p><p>Example: copy a file <code>&quot;a&quot;</code> into file <code>&quot;b&quot;</code>, removing blank lines:</p><pre><code class="ml">Iterator.(IO.lines_of &quot;a&quot; |&gt; filter (fun l-&gt; l&lt;&gt; &quot;&quot;) |&gt; IO.write_lines &quot;b&quot;);;</code></pre><p>By chunks of <code>4096</code> bytes:</p><pre><code class="ml">Iterator.IO.(chunks_of ~size:4096 &quot;a&quot; |&gt; write_to &quot;b&quot;);;</code></pre><p>Read the lines of a file into a list:</p><pre><code class="ml">Iterator.IO.lines &quot;a&quot; |&gt; Iterator.to_list</code></pre><dl><dt>since</dt><dd>0.5.1</dd></dl></header><div class="spec module" id="module-IO"><a href="#module-IO" class="anchor"></a><code><span class="keyword">module</span> IO = <a href="../../iter/Iter/index.html#module-IO">Iter.IO</a></code></div></section></details></div></div></div><dl><dt class="spec type" id="type-sequence"><a href="#type-sequence" class="anchor"></a><code><span class="keyword">type</span> 'a sequence</code><code> = <span class="type-var">'a</span> <a href="index.html#type-iter">iter</a></code></dt></dl></div></body></html>